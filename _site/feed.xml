<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>huailei blog</title>
    <description>Trust The Process</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 16 Nov 2019 20:17:40 +0800</pubDate>
    <lastBuildDate>Sat, 16 Nov 2019 20:17:40 +0800</lastBuildDate>
    <generator>Jekyll v3.8.3</generator>
    
      <item>
        <title>笔记-volatile内存语义</title>
        <description>&lt;h3 id=&quot;volatile的特性&quot;&gt;volatile的特性&lt;/h3&gt;
&lt;p&gt;理解volatile特性的一个好办法是把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写做了同步。一个volatile变量的单个读/写操作，与一个普通变量的读/写操作都是使用同一个锁来同步，它们之间执行效果相同。&lt;/p&gt;

&lt;p&gt;锁的happens-before规则保证释放锁和获取锁的两个线程之间的内存可见性，这意味着对一个volatile变量的读，总能看到任意线程对这个volatile变量最后的写入。&lt;/p&gt;

&lt;p&gt;volatile变量自身具有下列特性：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;可见性：对一个volatile变量的读，总能看到任意线程对这个volatile变量最后的写入。&lt;/li&gt;
  &lt;li&gt;原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作 不具有原子性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从内存语义来说，volatile的写-读与锁的释放-获取有相同的内存语义：volatile写和锁的释放有相同的内存语义；volatile读与锁的获取有相同的内存语义。&lt;/p&gt;

&lt;h3 id=&quot;volatile写-读的内存语义&quot;&gt;volatile写-读的内存语义&lt;/h3&gt;
&lt;p&gt;volatile写的内存语义：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。&lt;/p&gt;

&lt;p&gt;以VolatileExample为例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;class VolatileExample {
  int x = 0;
  volatile boolean v = false;
  public void writer() {
    x = 1;
    v = true;
  }
  public void reader() {
    if (v) {
      System.out.println(x);
      ······
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/huaileicoder/huaileicoder.github.io/blob/master/img/%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E7%8A%B6%E6%80%81%E7%A4%BA%E6%84%8F%E5%9B%BE1.png?raw=true&quot; alt=&quot;共享变量的状态示意图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，线程A在写flag变量之后，本地内存A中被线程A更新过的两个共享变量的值被刷新在主内存中。此时，本地内存A和主内存中的共享变量的值是一致的。&lt;/p&gt;

&lt;p&gt;volatile读的内存语义：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存读取共享变量。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/huaileicoder/huaileicoder.github.io/blob/master/img/%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E7%8A%B6%E6%80%81%E7%A4%BA%E6%84%8F%E5%9B%BE2.png?raw=true&quot; alt=&quot;共享变量的状态示意图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，在读flag变量后，本地内存B包含的值已经被置为无效。此时，线程B必须从主内存中读取共享变量。线程B的读取操作将导致本地内存B与主内存中的共享变量的值变成一致。&lt;/p&gt;

&lt;p&gt;如果把volatile写和volatile读两个步骤综合来看的话，在读线程B读一个volatile变量后，写线程A在写这个volatile变量之前所有可见的共享变量的值都会立即变得对读线程B可见。&lt;/p&gt;

&lt;p&gt;volatile写和volatile读的内存语义总结：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程发出了（其对共享变量所做修改的）消息。&lt;/li&gt;
  &lt;li&gt;线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile变量之前对共享变量所做修改的）消息&lt;/li&gt;
  &lt;li&gt;线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;volatile内存语义的实现&quot;&gt;volatile内存语义的实现&lt;/h3&gt;
&lt;p&gt;之前提到重排序分为编译器重排序和处理器重排序。为了实现volatile内存语义，JMM会分别限制这两种类型的重排序类型。下面是JMM针对编译器制定的volatile重排序规则。&lt;/p&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;是否能重排序&lt;/th&gt;
        &lt;th colspan=&quot;3&quot;&gt;第二个操作&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;第一个操作&lt;/th&gt;
        &lt;th&gt;普通读/写&lt;/th&gt;
        &lt;th&gt;volatile读&lt;/th&gt;
        &lt;th&gt;volatile写&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;普通读/写&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;NO&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;volatile读&lt;/td&gt;
        &lt;td&gt;NO&lt;/td&gt;
        &lt;td&gt;NO&lt;/td&gt;
        &lt;td&gt;NO&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;volatile写&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;NO&lt;/td&gt;
        &lt;td&gt;NO&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;上面表格意思是：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;当第一个操作是普通读/写时，如果第二个操作是volatile写时，则编译器不允许这种重排序。&lt;/li&gt;
  &lt;li&gt;当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。&lt;/li&gt;
  &lt;li&gt;当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。&lt;/li&gt;
  &lt;li&gt;当第一个操作是volatile写，第二个操作是volatile读时不允许重排序。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能。为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在每个volatile写操作的前面插入一个StoreStore屏障&lt;/li&gt;
  &lt;li&gt;在每个volatile写操作的后面插入一个StoreLoad屏障&lt;/li&gt;
  &lt;li&gt;在每个volatile读操作的后面插入一个LoadLoad屏障&lt;/li&gt;
  &lt;li&gt;在每个volatile读操作的后面插入一个LoadStore屏障&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面是保守策略下，volatile写插入内存屏障后生成的指令序列示意图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/huaileicoder/huaileicoder.github.io/blob/master/img/volatile%E5%86%99%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true&quot; alt=&quot;volatile写指令序列示意图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中的StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作已经对任意处理器可见了。这是因为StoreStore屏障将保障上面所有的普通写在volatile写之前刷新到主内存。&lt;/p&gt;

&lt;p&gt;volatile写后面的StoreLoad屏障作用是避免volatile写与后面可能有的volatile读/写操作重排序。因为编译器常常无法准确判断在一个volatile写的后面是否需要插入一个StoreLoad屏障（比如，一个volatile写之后直接return），为了保证volatile的内存语义，JMM采取保守策略：在每个volatile写的后面或者在每个volatile读的前面插入一个StoreLoad屏障。&lt;/p&gt;

&lt;p&gt;下面是保守策略下，volatile读插入内存屏障后生成的指令序列示意图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/huaileicoder/huaileicoder.github.io/blob/master/img/volatile%E8%AF%BB%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true&quot; alt=&quot;volatile读指令序列示意图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中的LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。&lt;/p&gt;

&lt;p&gt;但是在实际执行中，只要不改变volatile写-读的内存语义，编译器可以根据具体情况省略不必要的屏障。并且由于不同的处理器有不同“松紧度”的处理器内存模型，内存屏障的插入还可以根据具体的处理器内存模型继续优化。&lt;/p&gt;
</description>
        <pubDate>Sat, 16 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/11/16/%E7%AC%94%E8%AE%B0-volatile%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/11/16/%E7%AC%94%E8%AE%B0-volatile%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89.html</guid>
        
        <category>-concurrency</category>
        
        
      </item>
    
      <item>
        <title>笔记-并发编程bug的源头以及解决办法</title>
        <description>&lt;h3 id=&quot;缓存导致的可见性问题&quot;&gt;缓存导致的可见性问题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;可见性&lt;/strong&gt;是一个线程对共享变量的修改，另外一个线程能立刻看到。&lt;/p&gt;

&lt;p&gt;为了提高处理速度，处理器不直接与内存进行通信，而是先将系统内存的数据读到内部缓存后再进行操作，但操作完不知道何时会写到内存。对于单核来说，所有的线程都是运行在这个CPU上的，操作的都是同一份缓存。线程A更新了变量V的值，那么线程B之后再访问变量V,得到的一定是V的最新值。&lt;/p&gt;

&lt;p&gt;但是在多核上，每一个CPU都有自己的缓存，线程A运行在CPU-1上，操作的是CPU-1的缓存，线程B运行在CPU-2上，操作的是CPU-2的缓存。这时候线程A对于变量V的操作对于B就不具备可见性了。
&lt;img src=&quot;https://static001.geekbang.org/resource/image/e2/ea/e2aa76928b2bc135e08e7590ca36e0ea.png&quot; alt=&quot;多核CPU的缓存与内存关系图&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;可见性问题解决办法&quot;&gt;可见性问题解决办法&lt;/h3&gt;
&lt;p&gt;可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。这就需要一个CPU上缓存中的共享变量被修改，其他CPU就需要知道这个被修改的共享变量以及最新的值。但是如何做到信息的传递的呢？我们来看一下volatile是如何来保证可见性的？有volatile变量修饰的共享变量进行写操作的时候会引发下面两个操作：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;将当前处理器缓存行的数据写回系统内存&lt;/li&gt;
  &lt;li&gt;这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在多处理下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现 自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存中。通过这样就能保证一个线程修改共享变量之后，另外一个线程操作的是最新的值。&lt;/p&gt;

&lt;h3 id=&quot;线程切换带来的原子性问题&quot;&gt;线程切换带来的原子性问题&lt;/h3&gt;
&lt;p&gt;操作系统允许某个进程执行一小段时间，过了这小段时间就会再选择一个进程来执行，这小段时间被称为“&lt;strong&gt;时间片&lt;/strong&gt;”。
&lt;img src=&quot;https://static001.geekbang.org/resource/image/25/fb/254b129b145d80e9bb74123d6e620efb.png&quot; alt=&quot;线程切换示意图&quot; /&gt;
而执行每个线程的时间片是不一定的。有可能执行一条CPU指令就切换到其他线程执行了。
现在我们使用的都是高级语言，每一条语句都是解析成多条CPU指令的，比如count += 1就可以至少三条CPU指令。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;需要把变量count从内存加载到CPU的寄存器。&lt;/li&gt;
  &lt;li&gt;在寄存器中执行+1操作。&lt;/li&gt;
  &lt;li&gt;将结果写入内存（缓存机制是写入缓存，然后由缓存写入内存）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;操作系统做线程切换，可以发生在执行任何一条CPU指令之后，当A线程执行到1后发生线程切换，由B线程开始执行1，2，3三条CPU指令，B线程执行完之后再切换到A线程执行，最终我们会发现结果是1而不是2。这主要是三条CPU指令执行并不是一体的，我们把一个或多个操作在CPU执行的过程中不被中断的特性称为原子性，CPU只能保证执行CPU指令的时候具有原子性，不能保证执行多条CPU指令具有原子性。所以很多时候我们需要在高级语言层面保证操作的原子性。&lt;/p&gt;

&lt;h3 id=&quot;原子性问题解决办法&quot;&gt;原子性问题解决办法&lt;/h3&gt;
&lt;p&gt;在Java中可以通过&lt;strong&gt;锁&lt;/strong&gt;和&lt;strong&gt;循环CAS&lt;/strong&gt;的方式来实现原子操作。锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM中的CAS操作利用了处理器提供的CMPXCHG指令实现的，而CMPXCHG指令是处理器用来保证原子性的，处理器提供的这些指令，除了CMPXCHG之外还有位测试和修改指令（BTS、BTR、BTC）以及操作数和逻辑指令（如AD和OR），这些指令可以实现两个机制来保证处理器实现原子性，第一个机制是通过总线锁保证原子性，第二个机制是通过缓存锁定来保证原子性，被这些指令操作的内存区域就会加锁，导致其他处理器不能同时访问它。&lt;/p&gt;

&lt;h3 id=&quot;编译优化带来的有序性问题&quot;&gt;编译优化带来的有序性问题&lt;/h3&gt;
&lt;p&gt;有序性：指的是程序按照代码的先后顺序执行。&lt;/p&gt;

&lt;p&gt;为了提高性能，编译器和处理器常常会对指令做重排序。比如 a=1;b=2;可以被编译器优化后变成 b=2;a=1;这个例子中只是调整了语句的顺序，并没有改变最后的结果。
重排序的3种类型：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;编译器优化的重排序。编译器可以在不改变单线程语义的前提下，重新安排语句的执行顺序。&lt;/li&gt;
  &lt;li&gt;指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。&lt;/li&gt;
  &lt;li&gt;内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面说的1是编译器重排序，2和3是属于处理器重排序。这些重排序可能会导致多线程程序出现&lt;strong&gt;内存可见性问题&lt;/strong&gt;。在Java中有个经典的案例，双重检查创建单例对象。&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Singleton&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Singleton&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Singleton&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Singleton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Singleton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面代码表达的意思，如果第一次检查instance不为空，就不需要执行下面的加锁和初始化操作。因此，可以大幅降低synchronized带来的开销。多个线程试图在同一时间创建对象时，会通过加锁来保证只有一个线程能创建对象。在对象创建好之后，不需要获取锁直接返回已创建好的对象。好像非常完美，但还是有问题。问题就出现在new Singleton()上。创建一个对象，我们以为的操作是：
1、分配一块内存M；
2、在内存上初始化Singleton对象；
3、然后M的地址赋值给instance变量。&lt;/p&gt;

&lt;p&gt;但是可能实际优化之后的执行顺序是这样的：
1、分配一块内存M；
2、把M的地址赋值给instance变量；
3、最后在内存上初始化Singleton对象。&lt;/p&gt;

&lt;p&gt;优化后会导致通过getInstance()获取对象时，这个对象还没有在内存上初始化，如果此时访问instance的成员变量就有可能触发空指针异常。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://static001.geekbang.org/resource/image/64/d8/64c955c65010aae3902ec918412827d8.png&quot; alt=&quot;双重检查创建单例对象的异常执行路径&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;有序性问题解决办法&quot;&gt;有序性问题解决办法&lt;/h3&gt;
&lt;p&gt;从上面知道重排序可能会导致多线程程序出现内存可见性问题。为了保证内存可见性，最直接的办法就是&lt;strong&gt;禁止重排序&lt;/strong&gt;。对于编译器，JMM的编译器重排序规则会禁止特定类型的排序(例如volatile)，对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障(Memory Barriers)指令，通过内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指令分为4类：
屏障类型 | 指令示例 | 说明
—|—|—
LoadLoad Barriers | Load1;LoadLoad;Load2 | 确保Load1数据的装载先于Load2及所有后续装载指令的装载
StoreStore Barriers | Store1;StoreStore;Store2 | 确保Store1数据对其他处理器可见（刷新到内存）先于Store2及所有后续存储指令的存储
LoadStore Barriers | Load1;LoadStore;Store2 | 确保Load1数据装载先于Store2及所有后续的存储指令刷新到内存
StoreLoad Barriers | Store1;StoreLoad;Load2 | 确保Store1数据对其他处理器变得可见（指刷新到内存）先于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令&lt;/p&gt;

&lt;h3 id=&quot;java是如何解决可见性和有序性问题的&quot;&gt;Java是如何解决可见性和有序性问题的&lt;/h3&gt;
&lt;p&gt;从上面知道导致可见性问题的原因是缓存，导致有序性问题的原因是重排序。那么最直接的办法就是&lt;strong&gt;禁用缓存&lt;/strong&gt;和&lt;strong&gt;禁止重排序&lt;/strong&gt;。但是全部都禁用就会大大降低程序的性能，那么最好的方案就是&lt;strong&gt;按需禁用缓存和禁止重排序&lt;/strong&gt;。所以Java内存模型规范了JVM如何提供按需禁用缓存和禁止重排序的方法，具体来说就是&lt;strong&gt;volatile、synchronized和final&lt;/strong&gt;关键字，以及&lt;strong&gt;happens-before&lt;/strong&gt;规则。JMM使用happens-before的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间存在happens-before关系。这里的两个操作可以是在一个线程之内，也可以是在不同的线程之间。&lt;/p&gt;

&lt;p&gt;那如何理解happens-before规则呢？&lt;/p&gt;

&lt;p&gt;两个操作之间存在happens-before关系，并不是说前一个操作必须要在后一个操作之前执行，它真正表达的是&lt;strong&gt;前一个操作的结果对后续操作是可见的&lt;/strong&gt;。happens-before规则约束了编译器的优化行为，虽然允许编译器优化，但是要求编译器优化后一定要遵守happens-before规则。&lt;/p&gt;

&lt;p&gt;happens-before规则和程序员相关的共有六条规则，都是关于可见性的。&lt;/p&gt;

&lt;p&gt;1、程序的顺序型规则：是指在一个线程中，按照程序顺序，前面的操作happens-before于后续的任意操作。&lt;/p&gt;

&lt;p&gt;2、volatile变量规则：对一个volatile变量的写操作，happens-before于后续对这个变量的读操作。&lt;/p&gt;

&lt;p&gt;3、传递性：如果A happens-before B，B happens-before于 C，那么A happens-before 于 C。&lt;/p&gt;

&lt;p&gt;4、管程中锁的规则：对一个锁的解锁happens-before于后续对这个锁的加锁。管程是一种通用的同步原语，在 Java 中指的就是 synchronized。&lt;/p&gt;

&lt;p&gt;5、线程start规则：主线程A启动子线程B后，子线程B能看到主线程在启动子线程B前的操作。&lt;/p&gt;

&lt;p&gt;6、线程join()规则：主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程B 的 join() 方法实现），当子线程B完成后（主线A 中join()方法返回），主线程能够看到子线程的操作。&lt;/p&gt;

&lt;p&gt;下面用例子解释一下这六条happens-before规则：
因为volatile变量规则和锁的规则类似，这里只以1，2，3做说明。下面是以volatile写-读的示例。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;VolatileExample&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;writer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//1&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//2&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//3&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 这里 x 会是多少呢？&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//4&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面程序x的值是多少呢？如果是1.5之前的版本，结果可能是0，如果是1.5及之后的版本，结果就是1。
我们来用happens-before规则来分析一下这段程序的执行。假设此时线程A执行writer()方法，线程B执行reader()方法。&lt;/p&gt;

&lt;p&gt;从上面来看：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1 happens-before 2 和3 happens-before 4是由程序顺序规则来产生。&lt;/li&gt;
  &lt;li&gt;2 happens-before 3是由volatile变量规则来产生，因为由volatile变量规则，对一个volatile变量的读，总是能看到（任意线程）之前对这个volatile变量最后的写入。&lt;/li&gt;
  &lt;li&gt;1 happens-before 4是由传递性规则来产生。这里的传递性是由volatile的内存屏障插入策略和volatile的编译器重排序规则共同来保证的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么v被volatile修饰，操作1和操作2还可能重排序吗？如果没有的话，那么volatile做了哪些事情呢？&lt;/p&gt;

&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Java并发编程的艺术&lt;/li&gt;
  &lt;li&gt;Java并发编程实战&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://time.geekbang.org/column/intro/159&quot;&gt;Java并发编程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 09 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/11/09/%E7%AC%94%E8%AE%B0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8Bbug%E7%9A%84%E6%BA%90%E5%A4%B4%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/11/09/%E7%AC%94%E8%AE%B0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8Bbug%E7%9A%84%E6%BA%90%E5%A4%B4%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</guid>
        
        <category>-concurrency</category>
        
        
      </item>
    
      <item>
        <title>Java线程的生命周期</title>
        <description>&lt;h2 id=&quot;通用的线程周期&quot;&gt;通用的线程周期&lt;/h2&gt;
&lt;p&gt;通用的线程周期基本上可以用五个状态来表示。这个五个状态分别是：&lt;code class=&quot;highlighter-rouge&quot;&gt;初始状态&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;就绪状态&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;运行状态&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;休眠状态&lt;/code&gt;以及&lt;code class=&quot;highlighter-rouge&quot;&gt;终止状态&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;1、&lt;strong&gt;初始状态&lt;/strong&gt;：指的是线程已经被创建，但还不允许分配CPU执行。这个创建是指在编程语言层面被创建，在操作系统层面，线程还没有被创建。&lt;/p&gt;

&lt;p&gt;2、&lt;strong&gt;就绪状态&lt;/strong&gt;：指的是可以允许分配CPU执行。在这种状态下，真正的操作系统线程已经被创建了。&lt;/p&gt;

&lt;p&gt;3、&lt;strong&gt;运行状态&lt;/strong&gt;：当有空闲的CPU时，操作系统会将其分配给一个就绪状态的线程，被分配到CPU的线程状态就转换为运行状态。&lt;/p&gt;

&lt;p&gt;4、&lt;strong&gt;休眠状态&lt;/strong&gt;：运行状态的线程如果调用一个阻塞的API（例如以阻塞方式读文件）或者等待某个事件（例如条件变量），那么线程的状态就转换为休眠状态，同时释放CPU使用权，休眠状态的线程永远没有机会获得CPU使用权。当等待的事件出现了，线程就会自动从休眠状态转换为就绪状态。&lt;/p&gt;

&lt;p&gt;5、&lt;strong&gt;终止状态&lt;/strong&gt;：线程执行完成或者出现异常就会进入终止状态，终止状态的线程不会切换到其他线程，进入终止状态就说明线程的生命周期结束了。&lt;/p&gt;

&lt;p&gt;这五种状态在不同的编程语言中会有简化合并。比如Java中就把就绪状态和运行状态合并并称为运行状态。除此之外，这五种状态也有可能被细化，比如Java就细化了休眠状态。&lt;/p&gt;

&lt;h2 id=&quot;java的线程周期&quot;&gt;Java的线程周期&lt;/h2&gt;
&lt;p&gt;Java线程在运行的生命周期可能处于六种不同的状态，在给定的一个时刻，线程只能处于其中的一个状态。&lt;/p&gt;

&lt;p&gt;1、&lt;strong&gt;NEW&lt;/strong&gt;：初始状态，线程被构建，但是还没有调用start()方法。&lt;/p&gt;

&lt;p&gt;2、&lt;strong&gt;RUNNABLE&lt;/strong&gt;：运行状态，Java线程将操作系统中的就绪和运行两种状态笼统的称作为“运行中”。&lt;/p&gt;

&lt;p&gt;3、&lt;strong&gt;BLOCKED&lt;/strong&gt;：阻塞状态，表示线程阻塞于锁。&lt;/p&gt;

&lt;p&gt;4、&lt;strong&gt;WAITING&lt;/strong&gt;：等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）。&lt;/p&gt;

&lt;p&gt;5、&lt;strong&gt;TIME_WAITING&lt;/strong&gt;：超时等待状态，该状态不同于WAITING，它是可以在指定的时间自行返回的。&lt;/p&gt;

&lt;p&gt;6、&lt;strong&gt;TERMINATED&lt;/strong&gt;：终止状态，表示当前线程已经执行完毕。&lt;/p&gt;

&lt;p&gt;在操作系统层面，Java中BOLCKED、WAITING、TIME_WAITING三种状态是一中状态，即休眠状态。也就是说只要Java线程处于三种状态之一，那么这个线程永远没有CPU的使用权。&lt;/p&gt;

&lt;h3 id=&quot;状态的转换&quot;&gt;状态的转换&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/img/Java thread state.jpg&quot; alt=&quot;Java线程状态转换图&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;1从new到runnable状态&quot;&gt;1、从NEW到RUNNABLE状态&lt;/h4&gt;
&lt;p&gt;Java 刚创建出来的 Thread 对象就是 NEW 状态，而创建 Thread 对象主要有两种方法。一种是继承 Thread 对象，重写 run() 方法。&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyThread&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 线程需要执行的代码&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;......&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;MyThread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;另一种是实现 Runnable 接口，重写 run() 方法，并将该实现类作为创建 Thread 对象的参数。&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Runner&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 线程需要执行的代码&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;......&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2runnable与blocked状态转换&quot;&gt;2、RUNNABLE与BLOCKED状态转换&lt;/h4&gt;
&lt;p&gt;只有一种场景触发这种转换，就是线程等待synchronized的隐式锁。线程在进入synchronized关键字所修饰的方法或者代码块时会被阻塞，这时状态会从RUNNABLE转换到BLOCKED。而当等待的线程获取到synchronized的隐式锁时，就会从BLOCKED转换成RUNNABLE。&lt;/p&gt;

&lt;p&gt;但是阻塞在java.concurrent包中Lock接口的线程状态是等待状态，因为java.concurrent包中Lock接口对于阻塞的实现均使用LockSupport类中的相关方法。&lt;/p&gt;

&lt;p&gt;线程调用阻塞式API时，这时候线程状态是怎样呢？在操作系统层面，线程是会转到休眠状态的，但是在JVM层面，Java线程的状态不会发生变化，这时Java线程状态依然是RUNNABLE。&lt;strong&gt;JVM层面并不关心操作系统调度相关的状态&lt;/strong&gt;，因为在JVM看来，等待CPU使用权（此时操作系统处于就绪状态）和等待I/O（此时操作系统处于休眠状态）没有区别，都是在等待某个资源，所以都归入了RUNNABLE状态。另外平时说的调用阻塞式API，线程会阻塞，指的是操作系统线程的状态，并不是Java线程的状态。&lt;/p&gt;

&lt;h4 id=&quot;3runnable与waiting状态转换&quot;&gt;3、RUNNABLE与WAITING状态转换&lt;/h4&gt;
&lt;p&gt;有三种场景会触发RUNNABLE到WAITING状态的转换。&lt;/p&gt;

&lt;p&gt;第一种，获得synchronized的隐式锁，调用无参数的Object.wait()方法。调用wait()方法之后，当前线程会释放synchronized的隐式锁，线程状态由RUNNABLE变为WAITING。当其他线程调用Object.notify()或Object.notifyAll()方法之后，线程状态将由WAITING转换为BLOCKED状态，从wait()返回的前提是获得了调用对象的锁。&lt;/p&gt;

&lt;p&gt;第二种，调用无参数的Object.join()方法。如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。当线程A执行了thread.join()时，A的状态会从RUNNABLE变为WAITING。当thread执行完之后，A线程才会从WAITING变为RUNNABLE。我们可以来看一下join()方法的实现：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;millis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isAlive&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
       &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我们可以看到join()方法中调用wait()方法，在线程A中执行了thread.join()语句，也就相当于调用了thead.wait(long timeout)方法，timeout是0。当thread线程执行完，join()方法也就返回了。&lt;/p&gt;

&lt;p&gt;第三种，调用LockSupport.park()方法，前面已经说了java.concurrent包中Lock接口对于阻塞的实现均使用LockSupport类中的相关方法。调用LockSupport.park()方法，线程状态会从RUNNABLE变为WAITING。调用LockSupport.unpark(Thread)，线程状态又会从WAITING变为RUNNABLE。&lt;/p&gt;

&lt;h4 id=&quot;4runnable与time_waiting状态转换&quot;&gt;4、RUNNABLE与TIME_WAITING状态转换&lt;/h4&gt;
&lt;p&gt;TIMED_WAITING 和 WAITING 状态的区别，仅仅是触发条件多了超时参数。&lt;/p&gt;

&lt;p&gt;调用下面几个方法都可以将线程状态从RUNNBALE转换为TIME_WAITING。&lt;/p&gt;

&lt;p&gt;1、调用&lt;strong&gt;带超时参数&lt;/strong&gt;的 Thread.sleep(long mills)方法；&lt;/p&gt;

&lt;p&gt;2、获得 synchronized 隐式锁的线程，调用&lt;strong&gt;带超时参数&lt;/strong&gt;的Object.wait(long)方法；&lt;/p&gt;

&lt;p&gt;3、调用&lt;strong&gt;带超时参数&lt;/strong&gt;的Thread.join(long mills)方法；&lt;/p&gt;

&lt;p&gt;4、调用&lt;strong&gt;带超时参数&lt;/strong&gt;的LockSupport.parkNanos(long nanos)方法；&lt;/p&gt;

&lt;p&gt;5、调用&lt;strong&gt;带超时参数&lt;/strong&gt;的LockSupport.parkUntil(long deadline)方法；&lt;/p&gt;

&lt;p&gt;同样，线程状态从TIME_WAITING返回RUNNABLE和WAITING差不多，就多了如果没有通知，超时就会返回。&lt;/p&gt;

&lt;h4 id=&quot;5从runnable到terminated状态&quot;&gt;5、从RUNNABLE到TERMINATED状态&lt;/h4&gt;
&lt;p&gt;线程执行完run()方法之后，会自动转换为TERMINATED状态。当线程执行run()方法时抛出异常也会导致线程终止。如果想要主动终止一个线程，可以调用线程的interrupt()方法。&lt;/p&gt;

&lt;p&gt;中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作。线程可以通过检查自身是否被中断来进行响应，线程可以通过方法isInterrupted来进行判断是否被中断，也可以调用静态方法Thread.interrupted()来对当前线程的中断标识位进行复位。&lt;/p&gt;

&lt;p&gt;另外被中断的线程可以通过异常的方式获得通知，当线程处于WAITING、TIME_WAITING状态时，如果调用该线程的interrupt()方法，会使该线程返回到RUNNABLE状态，同时该线程的代码会触发InterruptedException异常。不过需要注意的是wait()、sleep()这些方法在抛出InterruptedException之前，JVM会先将该线程的中断标识位清除，然后抛出InterruptedException，此时调用isInterruped()方法将会返回false。比如下面代码本意是当前线程被中断之后，退出while(true)，实际上这是一个死循环。&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isInterrupted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;中断操作是一种简便的线程间交互方式，而这种交互方式最适合用来取消或停止任务。除了中断以外，还可以利用一个boolean变量来控制是否需要停止任务并终止该线程。
下面代码中，创建了一个线程CountThread，它不断进行变量累加，而主线程尝试对其进行中断操作和停止操作。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Shutdown&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Runner&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;one&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;countThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;one&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;CountThread&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;countThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 睡眠1秒，main线程对CountThread进行中断，使CountThread感知到中断而结束&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SleepUtils&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;countThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;Runner&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;two&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;countThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;two&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;CountThread&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;countThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 睡眠1秒，main线程对Runner two 进行取消，使CountThread感知到on为false而结束&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SleepUtils&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;two&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Runner&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isInterrupted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Count i = &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在上面例子中，main线程通过中断操作和cancel()方法均可使CountThread得以终止。这种通过标识位或者中断操作的方式能够使线程在终止时有机会去清理资源，而不是武断地将线程停止。&lt;/p&gt;
</description>
        <pubDate>Sat, 22 Jun 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/06/22/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/06/22/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html</guid>
        
        <category>-concurrency</category>
        
        
      </item>
    
      <item>
        <title>idea 快捷键</title>
        <description>&lt;h2 id=&quot;ctrl&quot;&gt;Ctrl&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;快捷键&lt;/th&gt;
      &lt;th&gt;介绍&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + F&lt;/td&gt;
      &lt;td&gt;在当前文件进行文本查找 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + R&lt;/td&gt;
      &lt;td&gt;在当前文件进行文本替换 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Z&lt;/td&gt;
      &lt;td&gt;撤销 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Y&lt;/td&gt;
      &lt;td&gt;删除光标所在行 或 删除选中的行 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + X&lt;/td&gt;
      &lt;td&gt;剪切光标所在行 或 剪切选择内容&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + C&lt;/td&gt;
      &lt;td&gt;复制光标所在行 或 复制选择内容&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + D&lt;/td&gt;
      &lt;td&gt;复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + W&lt;/td&gt;
      &lt;td&gt;递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + E&lt;/td&gt;
      &lt;td&gt;显示最近打开的文件记录列表 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + N&lt;/td&gt;
      &lt;td&gt;根据输入的 类名 查找类文件 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + G&lt;/td&gt;
      &lt;td&gt;在当前文件跳转到指定行处&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + J&lt;/td&gt;
      &lt;td&gt;插入自定义动态代码模板 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + P&lt;/td&gt;
      &lt;td&gt;方法参数提示显示 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Q&lt;/td&gt;
      &lt;td&gt;光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + U&lt;/td&gt;
      &lt;td&gt;前往当前光标所在的方法的父类的方法 / 接口定义 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + B&lt;/td&gt;
      &lt;td&gt;进入光标所在的方法/变量的接口或是定义处，等效于 Ctrl + 左键单击 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + K&lt;/td&gt;
      &lt;td&gt;版本控制提交项目，需要此项目有加入到版本控制才可用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + T&lt;/td&gt;
      &lt;td&gt;版本控制更新项目，需要此项目有加入到版本控制才可用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + H&lt;/td&gt;
      &lt;td&gt;显示当前类的层次结构&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + O&lt;/td&gt;
      &lt;td&gt;选择可重写的方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + I&lt;/td&gt;
      &lt;td&gt;选择可继承的方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + +&lt;/td&gt;
      &lt;td&gt;展开代码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + -&lt;/td&gt;
      &lt;td&gt;折叠代码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + /&lt;/td&gt;
      &lt;td&gt;注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + [&lt;/td&gt;
      &lt;td&gt;移动光标到当前所在代码的花括号开始位置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + ]&lt;/td&gt;
      &lt;td&gt;移动光标到当前所在代码的花括号结束位置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + F1&lt;/td&gt;
      &lt;td&gt;在光标所在的错误代码处显示错误信息 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + F3&lt;/td&gt;
      &lt;td&gt;调转到所选中的词的下一个引用位置 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + F4&lt;/td&gt;
      &lt;td&gt;关闭当前编辑文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + F8&lt;/td&gt;
      &lt;td&gt;在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + F9&lt;/td&gt;
      &lt;td&gt;执行 Make Project 操作&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + F11&lt;/td&gt;
      &lt;td&gt;选中文件 / 文件夹，使用助记符设定 / 取消书签 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + F12&lt;/td&gt;
      &lt;td&gt;弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Tab&lt;/td&gt;
      &lt;td&gt;编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + End&lt;/td&gt;
      &lt;td&gt;跳到文件尾&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Home&lt;/td&gt;
      &lt;td&gt;跳到文件头&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Space&lt;/td&gt;
      &lt;td&gt;基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Delete&lt;/td&gt;
      &lt;td&gt;删除光标后面的单词或是中文句 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + BackSpace&lt;/td&gt;
      &lt;td&gt;删除光标前面的单词或是中文句 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + 1,2,3…9&lt;/td&gt;
      &lt;td&gt;定位到对应数值的书签位置 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + 左键单击&lt;/td&gt;
      &lt;td&gt;在打开的文件标题上，弹出该文件路径 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + 光标定位&lt;/td&gt;
      &lt;td&gt;按 Ctrl 不要松开，会显示光标所在的类信息摘要&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + 左方向键&lt;/td&gt;
      &lt;td&gt;光标跳转到当前单词 / 中文句的左侧开头位置 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + 右方向键&lt;/td&gt;
      &lt;td&gt;光标跳转到当前单词 / 中文句的右侧开头位置 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + 前方向键&lt;/td&gt;
      &lt;td&gt;等效于鼠标滚轮向前效果 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + 后方向键&lt;/td&gt;
      &lt;td&gt;等效于鼠标滚轮向后效果 （必备）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;alt&quot;&gt;Alt&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;快捷键&lt;/th&gt;
      &lt;th&gt;介绍&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + `&lt;/td&gt;
      &lt;td&gt;显示版本控制常用操作菜单弹出层 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + Q&lt;/td&gt;
      &lt;td&gt;弹出一个提示，显示当前类的声明 / 上下文信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + F1&lt;/td&gt;
      &lt;td&gt;显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + F2&lt;/td&gt;
      &lt;td&gt;对于前面页面，显示各类浏览器打开目标选择弹出层&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + F3&lt;/td&gt;
      &lt;td&gt;选中文本，逐个往下查找相同文本，并高亮显示&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + F7&lt;/td&gt;
      &lt;td&gt;查找光标所在的方法 / 变量 / 类被调用的地方&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + F8&lt;/td&gt;
      &lt;td&gt;在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + Home&lt;/td&gt;
      &lt;td&gt;定位 / 显示到当前文件的 Navigation Bar&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + Enter&lt;/td&gt;
      &lt;td&gt;IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + Insert&lt;/td&gt;
      &lt;td&gt;代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + 左方向键&lt;/td&gt;
      &lt;td&gt;切换当前已打开的窗口中的子视图，比如Debug窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + 右方向键&lt;/td&gt;
      &lt;td&gt;按切换当前已打开的窗口中的子视图，比如Debug窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + 前方向键&lt;/td&gt;
      &lt;td&gt;当前光标跳转到当前文件的前一个方法名位置 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + 后方向键&lt;/td&gt;
      &lt;td&gt;当前光标跳转到当前文件的后一个方法名位置 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + 1,2,3…9&lt;/td&gt;
      &lt;td&gt;显示对应数值的选项卡，其中 1 是 Project 用得最多 （必备）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;shift&quot;&gt;Shift&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;快捷键&lt;/th&gt;
      &lt;th&gt;介绍&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Shift + F1&lt;/td&gt;
      &lt;td&gt;如果有外部文档可以连接外部文档&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Shift + F2&lt;/td&gt;
      &lt;td&gt;跳转到上一个高亮错误 或 警告位置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Shift + F3&lt;/td&gt;
      &lt;td&gt;在查找模式下，查找匹配上一个&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Shift + F4&lt;/td&gt;
      &lt;td&gt;对当前打开的文件，使用新Windows窗口打开，旧窗口保留&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Shift + F6&lt;/td&gt;
      &lt;td&gt;对文件 / 文件夹 重命名&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Shift + F7&lt;/td&gt;
      &lt;td&gt;在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Shift + F8&lt;/td&gt;
      &lt;td&gt;在 Debug 模式下，跳出，表现出来的效果跟 F9 一样&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Shift + F9&lt;/td&gt;
      &lt;td&gt;等效于点击工具栏的 Debug 按钮&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Shift + F10&lt;/td&gt;
      &lt;td&gt;等效于点击工具栏的 Run 按钮&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Shift + F11&lt;/td&gt;
      &lt;td&gt;弹出书签显示层 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Shift + Tab&lt;/td&gt;
      &lt;td&gt;取消缩进 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Shift + ESC&lt;/td&gt;
      &lt;td&gt;隐藏当前 或 最后一个激活的工具窗口&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Shift + End&lt;/td&gt;
      &lt;td&gt;选中光标到当前行尾位置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Shift + Home&lt;/td&gt;
      &lt;td&gt;选中光标到当前行头位置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Shift + Enter&lt;/td&gt;
      &lt;td&gt;开始新一行。光标所在行下空出一行，光标定位到新行位置 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Shift + 左键单击&lt;/td&gt;
      &lt;td&gt;在打开的文件名上按此快捷键，可以关闭当前打开文件 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Shift + 滚轮前后滚动&lt;/td&gt;
      &lt;td&gt;当前文件的横向滚动轴滚动 （必备）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;ctrl--alt&quot;&gt;Ctrl + Alt&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;快捷键&lt;/th&gt;
      &lt;th&gt;介绍&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Alt + L&lt;/td&gt;
      &lt;td&gt;格式化代码，可以对当前文件和整个包目录使用 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Alt + O&lt;/td&gt;
      &lt;td&gt;优化导入的类，可以对当前文件和整个包目录使用 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Alt + I&lt;/td&gt;
      &lt;td&gt;光标所在行 或 选中部分进行自动代码缩进，有点类似格式化&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Alt + T&lt;/td&gt;
      &lt;td&gt;对选中的代码弹出环绕选项弹出层 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Alt + J&lt;/td&gt;
      &lt;td&gt;弹出模板选择窗口，将选定的代码加入动态模板中&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Alt + H&lt;/td&gt;
      &lt;td&gt;调用层次&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Alt + B&lt;/td&gt;
      &lt;td&gt;在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Alt + C&lt;/td&gt;
      &lt;td&gt;重构-快速提取常量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Alt + F&lt;/td&gt;
      &lt;td&gt;重构-快速提取成员变量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Alt + V&lt;/td&gt;
      &lt;td&gt;重构-快速提取变量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Alt + Y&lt;/td&gt;
      &lt;td&gt;同步、刷新&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Alt + S&lt;/td&gt;
      &lt;td&gt;打开 IntelliJ IDEA 系统设置 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Alt + F7&lt;/td&gt;
      &lt;td&gt;显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Alt + F11&lt;/td&gt;
      &lt;td&gt;切换全屏模式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Alt + Enter&lt;/td&gt;
      &lt;td&gt;光标所在行上空出一行，光标定位到新行 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Alt + Home&lt;/td&gt;
      &lt;td&gt;弹出跟当前文件有关联的文件弹出层&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Alt + Space&lt;/td&gt;
      &lt;td&gt;类名自动完成&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Alt + 左方向键&lt;/td&gt;
      &lt;td&gt;退回到上一个操作的地方 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Alt + 右方向键&lt;/td&gt;
      &lt;td&gt;前进到上一个操作的地方 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Alt + 前方向键&lt;/td&gt;
      &lt;td&gt;在查找模式下，跳到上个查找的文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Alt + 后方向键&lt;/td&gt;
      &lt;td&gt;在查找模式下，跳到下个查找的文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Alt + 右括号（]）&lt;/td&gt;
      &lt;td&gt;在打开多个项目的情况下，切换下一个项目窗口&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Alt + 左括号（[）&lt;/td&gt;
      &lt;td&gt;在打开多个项目的情况下，切换上一个项目窗口&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;ctrl--shift&quot;&gt;Ctrl + Shift&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;快捷键&lt;/th&gt;
      &lt;th&gt;介绍&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + F&lt;/td&gt;
      &lt;td&gt;根据输入内容查找整个项目 或 指定目录内文件 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + R&lt;/td&gt;
      &lt;td&gt;根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + J&lt;/td&gt;
      &lt;td&gt;自动将下一行合并到当前行末尾 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + Z&lt;/td&gt;
      &lt;td&gt;取消撤销 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + W&lt;/td&gt;
      &lt;td&gt;递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + N&lt;/td&gt;
      &lt;td&gt;通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + U&lt;/td&gt;
      &lt;td&gt;对选中的代码进行大 / 小写轮流转换 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + T&lt;/td&gt;
      &lt;td&gt;对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + C&lt;/td&gt;
      &lt;td&gt;复制当前文件磁盘路径到剪贴板 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + V&lt;/td&gt;
      &lt;td&gt;弹出缓存的最近拷贝的内容管理器弹出层&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + E&lt;/td&gt;
      &lt;td&gt;显示最近修改的文件列表的弹出层&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + H&lt;/td&gt;
      &lt;td&gt;显示方法层次结构&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + B&lt;/td&gt;
      &lt;td&gt;跳转到类型声明处 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + I&lt;/td&gt;
      &lt;td&gt;快速查看光标所在的方法 或 类的定义&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + A&lt;/td&gt;
      &lt;td&gt;查找动作 / 设置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + /&lt;/td&gt;
      &lt;td&gt;代码块注释 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + [&lt;/td&gt;
      &lt;td&gt;选中从光标所在位置到它的顶部中括号位置 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + ]&lt;/td&gt;
      &lt;td&gt;选中从光标所在位置到它的底部中括号位置 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + +&lt;/td&gt;
      &lt;td&gt;展开所有代码 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + -&lt;/td&gt;
      &lt;td&gt;折叠所有代码 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + F7&lt;/td&gt;
      &lt;td&gt;高亮显示所有该选中文本，按Esc高亮消失 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + F8&lt;/td&gt;
      &lt;td&gt;在 Debug 模式下，指定断点进入条件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + F9&lt;/td&gt;
      &lt;td&gt;编辑器最大化 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + Space&lt;/td&gt;
      &lt;td&gt;智能代码提示&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + Enter&lt;/td&gt;
      &lt;td&gt;自动结束代码，行末自动添加分号 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + Backspace&lt;/td&gt;
      &lt;td&gt;退回到上次修改的地方 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + 1,2,3…9&lt;/td&gt;
      &lt;td&gt;快速添加指定数值的书签 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + 左键单击&lt;/td&gt;
      &lt;td&gt;把光标放在某个类变量上，按此快捷键可以直接定位到该类中 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + 左方向键&lt;/td&gt;
      &lt;td&gt;在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + 右方向键&lt;/td&gt;
      &lt;td&gt;在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + 前方向键&lt;/td&gt;
      &lt;td&gt;光标放在方法名上，将方法移动到上一个方法前面，调整方法排序 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + 后方向键&lt;/td&gt;
      &lt;td&gt;光标放在方法名上，将方法移动到下一个方法前面，调整方法排序 （必备）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;alt--shift&quot;&gt;Alt + Shift&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;快捷键&lt;/th&gt;
      &lt;th&gt;介绍&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + Shift + N&lt;/td&gt;
      &lt;td&gt;选择 / 添加 task （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + Shift + F&lt;/td&gt;
      &lt;td&gt;显示添加到收藏夹弹出层 / 添加到收藏夹&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + Shift + C&lt;/td&gt;
      &lt;td&gt;查看最近操作项目的变化情况列表&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + Shift + I&lt;/td&gt;
      &lt;td&gt;查看项目当前文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + Shift + F7&lt;/td&gt;
      &lt;td&gt;在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + Shift + F9&lt;/td&gt;
      &lt;td&gt;弹出 Debug 的可选择菜单&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + Shift + F10&lt;/td&gt;
      &lt;td&gt;弹出 Run 的可选择菜单&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + Shift + 左键双击&lt;/td&gt;
      &lt;td&gt;选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + Shift + 前方向键&lt;/td&gt;
      &lt;td&gt;移动光标所在行向上移动 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + Shift + 后方向键&lt;/td&gt;
      &lt;td&gt;移动光标所在行向下移动 （必备）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;ctrl--shift--alt&quot;&gt;Ctrl + Shift + Alt&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;快捷键&lt;/th&gt;
      &lt;th&gt;介绍&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + Alt + V&lt;/td&gt;
      &lt;td&gt;无格式黏贴 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + Alt + N&lt;/td&gt;
      &lt;td&gt;前往指定的变量 / 方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + Alt + S&lt;/td&gt;
      &lt;td&gt;打开当前项目设置 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + Alt + C&lt;/td&gt;
      &lt;td&gt;复制参考信息&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;快捷键&lt;/th&gt;
      &lt;th&gt;介绍&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;F2&lt;/td&gt;
      &lt;td&gt;跳转到下一个高亮错误 或 警告位置 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;F3&lt;/td&gt;
      &lt;td&gt;在查找模式下，定位到下一个匹配处&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;F4&lt;/td&gt;
      &lt;td&gt;编辑源 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;F7&lt;/td&gt;
      &lt;td&gt;在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;F8&lt;/td&gt;
      &lt;td&gt;在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;F9&lt;/td&gt;
      &lt;td&gt;在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;F11&lt;/td&gt;
      &lt;td&gt;添加书签 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;F12&lt;/td&gt;
      &lt;td&gt;回到前一个工具窗口 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Tab&lt;/td&gt;
      &lt;td&gt;缩进 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ESC&lt;/td&gt;
      &lt;td&gt;从工具窗口进入代码文件窗口 （必备）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;连按两次Shift&lt;/td&gt;
      &lt;td&gt;弹出 Search Everywhere 弹出层&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
        <pubDate>Sat, 15 Jun 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/06/15/idea-%E5%BF%AB%E6%8D%B7%E9%94%AE.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/06/15/idea-%E5%BF%AB%E6%8D%B7%E9%94%AE.html</guid>
        
        <category>-tools</category>
        
        
      </item>
    
      <item>
        <title>volatile内存语义</title>
        <description>&lt;h3 id=&quot;volatile的特性&quot;&gt;volatile的特性&lt;/h3&gt;
&lt;p&gt;理解volatile特性的一个好办法是把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写做了同步。一个volatile变量的单个读/写操作，与一个普通变量的读/写操作都是使用同一个锁来同步，它们之间执行效果相同。&lt;/p&gt;

&lt;p&gt;锁的happens-before规则保证释放锁和获取锁的两个线程之间的内存可见性，这意味着对一个volatile变量的读，总能看到任意线程对这个volatile变量最后的写入。锁的语义决定了临界区代码的执行具有原子性。&lt;/p&gt;

&lt;p&gt;volatile变量自身具有下列特性：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;可见性：对一个volatile变量的读，总能看到任意线程对这个volatile变量最后的写入。&lt;/li&gt;
  &lt;li&gt;原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作 不具有原子性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从JDK1.5开始，volatile变量的读/写可以实现线程之间的通信。&lt;/p&gt;

&lt;p&gt;从内存语义来说，volatile的写-读与锁的释放-获取有相同的内存语义；volatile写和锁的释放有相同的内存语义；volatile读与锁的获取有相同的内存语义。&lt;/p&gt;

&lt;h3 id=&quot;volatile写-读的内存语义&quot;&gt;volatile写-读的内存语义&lt;/h3&gt;
&lt;p&gt;volatile写的内存语义：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。&lt;/p&gt;

&lt;p&gt;volatile读的内存语义：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存读取共享变量。&lt;/p&gt;

&lt;p&gt;volatile写和volatile读的内存语义总结：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程发出了（其对共享变量所做修改的）消息。&lt;/li&gt;
  &lt;li&gt;线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile变量之前对共享变量所做修改的）消息&lt;/li&gt;
  &lt;li&gt;线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;内存屏障&quot;&gt;内存屏障&lt;/h3&gt;
&lt;p&gt;JMM把内存屏障指令分为4类：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;屏障类型&lt;/th&gt;
      &lt;th&gt;指令示例&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;LoadLoad Barriers&lt;/td&gt;
      &lt;td&gt;Load1;LoadLoad;Load2&lt;/td&gt;
      &lt;td&gt;确保Load1数据的装载先于Load2及所有后续装载指令的装载&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;StoreStore Barriers&lt;/td&gt;
      &lt;td&gt;Store1;StoreStore;Store2&lt;/td&gt;
      &lt;td&gt;确保Store1数据对其他处理器可见（刷新到内存）先于Store2及所有后续存储指令的存储&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LoadStore Barriers&lt;/td&gt;
      &lt;td&gt;Load1;LoadStore;Store2&lt;/td&gt;
      &lt;td&gt;确保Load1数据装载先于Store2及所有后续的存储指令刷新到内存&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;StoreLoad Barriers&lt;/td&gt;
      &lt;td&gt;Store1;StoreLoad;Load2&lt;/td&gt;
      &lt;td&gt;确保Store1数据对其他处理器变得可见（指刷新到内存）先于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他3个屏障的效果。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区的数据全部刷新到内存中（Buffer Fully Flush）。&lt;/p&gt;

&lt;h3 id=&quot;volatile内存语义的实现&quot;&gt;volatile内存语义的实现&lt;/h3&gt;
&lt;p&gt;为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能。为此，JMM采取保守策略。可以看到JMM实现上的一个特点：&lt;strong&gt;首先确保正确性，然后再去追求执行效率&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在每个volatile写操作的前面插入一个StoreStore屏障&lt;/li&gt;
  &lt;li&gt;在每个volatile写操作的后面插入一个StoreLoad屏障&lt;/li&gt;
  &lt;li&gt;在每个volatile读操作的后面插入一个LoadLoad屏障&lt;/li&gt;
  &lt;li&gt;在每个volatile读操作的后面插入一个LoadStore屏障&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在实际执行中，只要不改变volatile写-读的内存语义，编译器可以根据具体情况省略不必要的屏障。&lt;/p&gt;
</description>
        <pubDate>Sat, 01 Jun 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/06/01/volatile%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/06/01/volatile%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89.html</guid>
        
        <category>-concurrency</category>
        
        
      </item>
    
      <item>
        <title>代码整洁之道-总结</title>
        <description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;学习整洁代码很难。它可不止于要求你掌握原则和模式。你得在这上面花功夫，你须自行实践，且体验自己的失败。你须观察他人的实践与失败。你须看看别人是怎样蹒跚学步，再转头研究他们的路数。你须看看别人是如何绞尽脑汁做出抉择，又是如何为错误决策付出代价。&lt;/p&gt;

&lt;p&gt;如何学习？阅读代码——大量代码。而且你要去琢磨某段代码好在什么地方、坏在什么地方。
你得分析和理解那些代码，琢磨每次修改的来龙去脉。&lt;/p&gt;

&lt;p&gt;花时间琢磨那些案例，亦步亦趋——站在作者的角度，迫使自己以作者的思维路径考虑问题，就能更深刻的理解这些原则、模式、实践和启示。&lt;/p&gt;

&lt;h2 id=&quot;整洁代码&quot;&gt;整洁代码&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;blockquote&gt;
      &lt;p&gt;代码逻辑应当直接了当，叫缺陷难以隐藏；尽量减少依赖关系，使之便于维护；依据某种分层战略完善处理错误代码；性能调至最优，省的引诱别人做没规矩的优化，搞出一堆混乱来。整洁的代码只做一件事。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;糟糕的代码想做太多事，它意图混乱、目的含混。整洁的代码力求集中。每个函数、每个类和每个模块都全神贯注于一事，完全不受四周细节的干扰和污染。&lt;/p&gt;

&lt;p&gt;对于重复代码：如果同一段代码反复出现，就表示某种想法未在代码中得到良好的体现。我尽力去找出到底那是什么，然后再尽力更清晰的表达出来。&lt;/p&gt;

&lt;p&gt;童子军军规：让营地比你来时更干净&lt;/p&gt;

&lt;h3 id=&quot;有意义的命名&quot;&gt;有意义的命名&lt;/h3&gt;
&lt;h4 id=&quot;名副其实&quot;&gt;名副其实&lt;/h4&gt;
&lt;p&gt;名副其实应该是什么样的，变量、方法和类的名称应该已经回复了所有的大问题。它该告诉你，&lt;code class=&quot;highlighter-rouge&quot;&gt;它为什么存在，它做什么事，应该怎么用&lt;/code&gt;。如果名称需要注释来补充，那就不算是名副其实。&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 消逝的时间，以天记&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;名称d并没有表达出这个变量的意思。我们应该选择指明了计量对象和计量单位的名称；&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elapseTimeInDays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;daysSinceCreation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;daysSinceModification&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fileAgeInDays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;选择体现本意的名称能让人更容易理解和修改代码。能正确理解下面代码要做什么事情吗？&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getThem&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;theList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;list1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面代码说明要做什么事？我们无法从代码中直接看出。问题不在于代码的简洁度，而是在于代码的&lt;strong&gt;模糊度&lt;/strong&gt;：即上下文在代码中未被明确体现的程度。上述代码要求我们了解这几件事情:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;theList是什么类型的东西？&lt;/li&gt;
  &lt;li&gt;theList零下标条目的意义是什么？&lt;/li&gt;
  &lt;li&gt;值4的意义是什么？&lt;/li&gt;
  &lt;li&gt;我该怎么使用返回的列表？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;问题的答案没体现在代码中，可那就是它们该在的地方。&lt;/p&gt;

&lt;h4 id=&quot;避免误导&quot;&gt;避免误导&lt;/h4&gt;
&lt;p&gt;程序员必须避免留下掩藏代码本意的错误线索。应当避免使用与本意相悖的词。例如，aix和sco都不该用作变量名，因为它们都是UNIX平台的专有名称。因为如果其他地方使用的话会让大家第一时间联想到UNIX下变量的意思，而不是当前情景下的意思，影响他人理解。
在名称中不要List，Map，Set等容器类型名。例如，别用accountList来指称一组账号，如果包含账号的容器并非是一个List，就会引起错误的判断。即便容器就是个List，最好也别在名称中写出容器类型名。
提防使用不同之处较小的名称。你能一下就区分开XYZControllerForEfficientHandlingOfStrings和另一处的XYZControllerForEfficientStorageOfStrings吗？
以同样的方式拼写出同样的概念才是信息，拼写前后不一致就是误导。&lt;/p&gt;

&lt;h4 id=&quot;做有意义的区分&quot;&gt;做有意义的区分&lt;/h4&gt;
&lt;p&gt;以数字系列命名（a1、a2，······aN）是依立命名的对立面。这样的名称纯属误导——完全没有提供正确的信息；没有提供导向作者意图的线索。
&lt;code class=&quot;highlighter-rouge&quot;&gt;废话是另一种没意义的区分&lt;/code&gt;。假设你有一个Product类。如果还有一个ProductInfo或ProductData类，那它们的名称虽然不同，意思却无区别。Info和Data就像a、an、和the一样是意义含混的废话。
&lt;code class=&quot;highlighter-rouge&quot;&gt;废话都是冗余&lt;/code&gt;。
要区分名称，就要以读者能鉴别出不同之处的方式来区分。如果缺少明确约定，变量moneyAmonut就与money没区别，accountData与account没区别。&lt;/p&gt;

&lt;h4 id=&quot;使用可搜索的名称&quot;&gt;使用可搜索的名称&lt;/h4&gt;
&lt;p&gt;长名称长余短名称（这里的短名称是指单个字母或者简写的名称，长名称的长度应该是可以让别人理解的最短长度，不要一味的为了长而长，只要短名称足够清楚，就要比长名称好。别给名称添加不必要的语境，精确才是命名的要点）。&lt;code class=&quot;highlighter-rouge&quot;&gt;名称长短应与其作用域大小相对应&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;避免使用编码&quot;&gt;避免使用编码&lt;/h4&gt;
&lt;p&gt;不要把类型或者作用域编进名称里面。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PhoneNumber phoneString; // 类型变化时，名称并不变化
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;也不必用 &lt;em&gt;m_&lt;/em&gt; 前缀来标明成员变量。应当把类和函数做的足够小，消除对成员前缀的需要。&lt;/p&gt;

&lt;h3 id=&quot;避免思维映射&quot;&gt;避免思维映射&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;blockquote&gt;
      &lt;p&gt;明确是王道&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不应当让读者在脑中把你的名称翻译为他们熟知的名称。这种问题经常出现在选择是使用问题领域术语还是解决方案领域术语时。
类名和对象名应该是名词或名词短语，类名不应当是动词。命名类名的良好习惯是采用一个名词（Order）、前面有形容词修饰的名词（RushOrder）或动名词（有“-ing”后缀）修饰名词（例如，BillingAddress）。
方法名应该是动词或动词短语。属性访问器、修改器和断言应该根据其值命名，并依JavaBean标准加上get、set和is前缀。
重载构造器时，使用描述了参数的静态工厂方法名。例如：&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fulcrumPoint&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;FromRealNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;23.0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;通常好于&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fulcrumPoint&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;23.0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;给每个抽象概念选一个词，并且一以贯之。
避免将同一单词用于不同目的。&lt;/p&gt;

&lt;h2 id=&quot;方法&quot;&gt;方法&lt;/h2&gt;
&lt;p&gt;方法需要做的事情：&lt;/p&gt;

&lt;p&gt;1、&lt;code class=&quot;highlighter-rouge&quot;&gt;短小&lt;/code&gt;。方法的第一规则是要短小，第二条规则还要更短小。方法20行封顶最佳。
if语句、else语句、while语句等，其中的代码块应该只有一行。该行大抵应该是一个函数调用语句。这样不但能保持方法短小，而且，因为块内调用的方法拥有具有说明性的名称，从而增加了文档上的价值。这也意味着方法不应该大到足以容纳嵌套结构。所有，方法的缩进层级不该多于一层或者两层。&lt;/p&gt;

&lt;p&gt;2、&lt;code class=&quot;highlighter-rouge&quot;&gt;方法应该只做一件事，做好这件事，只做这一件事&lt;/code&gt;。如果方法只是做了该方法名下同一抽象层上的步骤，则函数还是只做了一件事。编写方法毕竟是为了把大一些的概念拆分为另一抽象层上的一系列步骤。要判断方法是否不止做了一件事，还有一个方法，就是看是否能再拆出一个方法，该方法不仅只是单纯的重新诠释其实现。&lt;/p&gt;

&lt;p&gt;3、&lt;code class=&quot;highlighter-rouge&quot;&gt;每一个方法一个抽象层级&lt;/code&gt;。方法中混杂不同抽象层级，往往让人迷惑。读者可能无法判断某个表达式是基础概念还是细节。更恶劣的是，就像是破损的窗户，一旦细节与基础概念混杂，更多的细节就会在方法中纠结起来。
有一个向下规则，我们想要让每个方法后面都跟着位与下一抽象层级的方法，这样一来，在查看方法列表时，就能循抽象层级向下阅读了。换一种说法：程序就像是一系列TO起头的段落，每一段都描述当前抽象层级，并引用位于下一抽象层级的后续TO起头段落。&lt;/p&gt;

&lt;p&gt;4、&lt;code class=&quot;highlighter-rouge&quot;&gt;沃德原则：如果每个例程都让你感到深合己意，那就是整洁代码&lt;/code&gt;。要遵循这一原则，泰半工作都在于为只做一件事的方法取个好名字。方法越短小、功能越集中，就越便于取名字。
别害怕长名称。长而具有描述性的名称，要比短而令人费解的名称好。长而具有描述性的名称，要比描述性的长注释好。
别害怕花时间取名字。你当尝试不同的名称，实测其阅读效果。
选择描述性的名称能理清你关于模块的设计思路，并帮你改进之。
命名方式要保持一致。使用与模块名一脉相承的短语、名词和动词给方法命名。&lt;/p&gt;

&lt;p&gt;5、&lt;code class=&quot;highlighter-rouge&quot;&gt;方法参数&lt;/code&gt;。最理想的参数数量是零，其次是一，再次是二，应尽量避免三。输出参数比输入参数还要难以理解，读方法时，我们惯于认为信息通过参数输入方法，通过返回值从方法中输出。我们不太期望信息通过参数输出，所以，输出参数往往让人苦思之后才恍然大悟。
如果方法看来需要两个、三个或三个以上参数，就说明其中一些参数应该封装为类了。从参数法创建对象，从而减少参数数量，看起来像是在作弊，但实则并非如此。当一组参数被共同传递，往往就是该有自己名称的某个概念的一部分。&lt;/p&gt;

&lt;p&gt;6、&lt;code class=&quot;highlighter-rouge&quot;&gt;分隔指令与询问&lt;/code&gt;。方法要么做什么事，要么回答什么事，但二者不可兼得。&lt;/p&gt;

&lt;p&gt;7、&lt;code class=&quot;highlighter-rouge&quot;&gt;抽离try/catch代码块&lt;/code&gt;。try/catch代码块丑陋不堪。它们搞乱了代码结构，把错误处理与正常流程混为一谈。最好把try和catch代码块的主体部分抽离出来，另外形成方法。&lt;/p&gt;

&lt;p&gt;如何写出这样的方法？写代码和写别的东西很像。在写论文或文章时，你先想什么就写什么，然后打磨它。初稿也许粗陋无序，你就斟酌推敲，直至达到你心目中的样子。&lt;code class=&quot;highlighter-rouge&quot;&gt;大师级程序员把系统当做故事来讲，而不是当做程序来写&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;注释&quot;&gt;注释&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;blockquote&gt;
      &lt;p&gt;注释应该谈及代码没提到的东西。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;什么也比不上放置良好的注释来得有用，什么也不会比乱七八糟的注释更有本事搞乱一个模块，什么也不会比陈旧、提供错误信息的注释更有破坏性。注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败。&lt;/p&gt;

&lt;p&gt;为什么极力贬低注释？因为注释会撒谎。也不是说总是如此或有意如此，但出现的实在太频繁。注释存在的时间越久，就离其所描述的代码越远，越来越变得全然错误。原因很简单，程序员不能坚持维护注释。代码在变动，在演化。从这里移到那里。彼此分离、重造又合到一处。很不幸，注释并不总是随之变动——不能总是跟着走。注释常常会与其所描述的代码分离开来，孑然飘零，越来越不准确。&lt;/p&gt;

&lt;p&gt;程序员应当负责将注释保持在可维护、有关联、精确的高度。但更好的方式把力气用在写清楚代码上，只有代码能忠实的告诉你它做的事情，那是唯一真正准确的信息来源。所以，尽管有时也需要注释，我们也该多花心思尽量减少注释量。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;注释不能美化槽糕的代码&lt;/code&gt;。写注释的常见动机之一是糟糕的代码的存在。带有少量注释的整洁而有表达力的代码，要比带有大量注释的零碎而复杂的代码像样的多。与其花时间编写解释你搞出的糟糕的代码的注释，不如花时间清洁那堆糟糕的代码。&lt;/p&gt;

&lt;h3 id=&quot;好注释&quot;&gt;好注释&lt;/h3&gt;
&lt;p&gt;有些注释是必须的，也是有利的。不过唯一真正好的注释是你想办法不去写的注释。来看一下什么样的注释是应该写的。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;对意图的解释&lt;/code&gt;。有时，注释不仅提供了有关实现的有用信息，而且还提供了某个决定后面的意图。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;阐释&lt;/code&gt;。有时，注释把某些晦涩难懂的参数或返回值的意义翻译为某种可读形式，也会是有用的。通常，更好的方法时尽量让参数或返回值自身就足够清楚；但如果参数或返回值的某个标准库的一部分，或是你不能修改的代码，帮助阐释其含义的代码就会有用。当然，这也会冒阐释性注释本身就不正确的风险。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;警示&lt;/code&gt;。有时，用于警告其他程序员会出现某种后果的注释也是有用的。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TODO注释&lt;/code&gt;。有时，有理由用//TODO形式在源代码中放置要做的工作列表。它可能是要提醒删除某个不必要的特性，或者要求其他人注意某个问题，或者提示对依赖于某个计划事件的修改。另外，你不会愿意代码因为TODO的存在而变成一堆垃圾，所以要定期查看，删除不再需要的。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;放大&lt;/code&gt;。注释可以用来放大某种看来不合理之物的重要性。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;公共API中的Javadoc&lt;/code&gt;。没有什么比被良好描述的公共API更有用和令人满意的了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;坏注释&quot;&gt;坏注释&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;误导性注释&lt;/code&gt;。如果注释不够准确还是没有的好。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;循规式注释&lt;/code&gt;。所谓每个方法都要有Javadoc或每个变量都要有注释的规矩全然是愚蠢可笑的。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;废话注释&lt;/code&gt;。不知道你看到下面这段注释是什么感受？
```java
/**&lt;/li&gt;
  &lt;li&gt;Default constructor
*/
protected AnnualDateRule(){}
```&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;不明显的联系&lt;/code&gt;。注释及其描述的代码之间的联系应该显而易见。如果你不嫌麻烦要写注释，至少让读者能看着注释和代码，并理解注释所谈何物。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;方法头&lt;/code&gt;。短方法不需要太多描述。为只做一件事的短方法选个好名字，通常要比写方法头注释要好。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 06 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/06/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93-%E6%80%BB%E7%BB%93.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/06/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93-%E6%80%BB%E7%BB%93.html</guid>
        
        <category>-clean</category>
        
        <category>code</category>
        
        
      </item>
    
      <item>
        <title>测试代码覆盖率工具Emma</title>
        <description>&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;在这里介绍一下代码覆盖率工具Emma的安装使用以及代码覆盖率的意义。&lt;/p&gt;

&lt;h2 id=&quot;代码覆盖率的意义&quot;&gt;代码覆盖率的意义&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;blockquote&gt;
      &lt;p&gt;把测试覆盖作为质量目标没有任何意义，而我们应该把它作为一种发现未被测试覆盖的代码的手段。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;首先需要明确这样一个概念，测试覆盖率并不是一定要达到多少才行，测试覆盖率并不是作为质量指标，代码覆盖率统计不能完全用来衡量代码质量。&lt;/p&gt;

&lt;p&gt;代码覆盖率存在的意义在于：
1、分析未覆盖部分的代码，从而反推在前期测试设计是否充分，没有覆盖到的代码是否是测试设计的盲点，为什么没有考虑到？需求/设计不够清晰，测试设计的理解有误，工程方法应用后的造成的策略性放弃等等，之后进行补充测试用例设计。
2、检测出程序中的废代码，可以逆向反推在代码设计中思维混乱点，提醒设计/开发人员理清代码逻辑关系，提升代码质量。
3、代码覆盖率高不能说明代码质量高，但是反过来看，代码覆盖率低，代码质量不会高到哪里去，可以作为测试自我审视的重要工具之一。&lt;/p&gt;

&lt;h2 id=&quot;代码覆盖率工具&quot;&gt;代码覆盖率工具&lt;/h2&gt;
&lt;p&gt;在这里只介绍Emma，Emma的原理可以修改Jar文件、class文件字节码文件，覆盖粒度包含行、块、方法、类，性能较快。关于工具工作的流程和原理可以学习这篇文章&lt;a href=&quot;https://tech.youzan.com/code-coverage/&quot;&gt;浅谈代码覆盖率&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;安装步骤eclipse&quot;&gt;安装步骤（eclipse）&lt;/h2&gt;
&lt;p&gt;1、Help——Install New SoftWare——add&lt;/p&gt;

&lt;p&gt;2、Add下边的内容：
Name:eclemma
URL:http://update.eclemma.org/&lt;/p&gt;

&lt;p&gt;3、安装 、重启&lt;/p&gt;

&lt;h2 id=&quot;使用eclipse&quot;&gt;使用（eclipse）&lt;/h2&gt;
&lt;p&gt;1、调出Coverage
Window——show view ——other ——java——Coverage
2、用Coverage启动程序
3、跑要测试的代码，打开要测试的代码，刷新执行Coverage，覆盖率也会更新&lt;/p&gt;

&lt;p&gt;idea下Emma的安装和使用请参考https://www.w3cschool.cn/intellij_idea_doc/intellij_idea_doc-h3yp2fhz.html&lt;/p&gt;

&lt;p&gt;参考链接：https://tech.youzan.com/code-coverage/&lt;/p&gt;
</description>
        <pubDate>Mon, 22 Apr 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/04/22/%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E5%B7%A5%E5%85%B7Emma.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/04/22/%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E5%B7%A5%E5%85%B7Emma.html</guid>
        
        <category>-tools</category>
        
        
      </item>
    
      <item>
        <title>Sublime 快捷键</title>
        <description>&lt;h3 id=&quot;一般操作&quot;&gt;一般操作&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;快捷键&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + P&lt;/td&gt;
      &lt;td&gt;打开命令框&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + K + B&lt;/td&gt;
      &lt;td&gt;打开侧边栏&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;搜索&quot;&gt;搜索&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;快捷键&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + F&lt;/td&gt;
      &lt;td&gt;打开底部的搜索框&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + H&lt;/td&gt;
      &lt;td&gt;代替&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + F&lt;/td&gt;
      &lt;td&gt;按照文件夹进行搜索&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + P&lt;/td&gt;
      &lt;td&gt;搜索当前workspace的文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + R&lt;/td&gt;
      &lt;td&gt;打开搜索框，自动代入@；前往符号，函数名称等&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + ;&lt;/td&gt;
      &lt;td&gt;打开搜索框，自动代入#；前往名称、属性等&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + G&lt;/td&gt;
      &lt;td&gt;打开搜索框，自动代入: 前往当前文件某行&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;编辑操作&quot;&gt;编辑操作&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;快捷键&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Enter&lt;/td&gt;
      &lt;td&gt;在下一行插入新行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + Enter&lt;/td&gt;
      &lt;td&gt;在上一行插入新行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + ↑&lt;/td&gt;
      &lt;td&gt;将所在行和上一行互换&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + ↓&lt;/td&gt;
      &lt;td&gt;将所在行和下一行互换&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + D&lt;/td&gt;
      &lt;td&gt;选取词，继续操作则会继续选取相同词的文字&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + ]&lt;/td&gt;
      &lt;td&gt;向右对齐&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + [&lt;/td&gt;
      &lt;td&gt;向左对齐&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + /&lt;/td&gt;
      &lt;td&gt;注解单行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + /&lt;/td&gt;
      &lt;td&gt;注解多行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Z&lt;/td&gt;
      &lt;td&gt;撤销&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;分页操作&quot;&gt;分页操作&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;快捷键&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + T&lt;/td&gt;
      &lt;td&gt;开启最后关闭的页面&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + PgUp&lt;/td&gt;
      &lt;td&gt;向左切换页面&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + PgDown&lt;/td&gt;
      &lt;td&gt;向右切换页面&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Tab&lt;/td&gt;
      &lt;td&gt;按照分页浏览过的顺序切换页面&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;分屏操作&quot;&gt;分屏操作&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;快捷键&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + Shift + 1&lt;/td&gt;
      &lt;td&gt;Single&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + Shift + 2&lt;/td&gt;
      &lt;td&gt;Columns:2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + Shift + 3&lt;/td&gt;
      &lt;td&gt;Columns:3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + Shift + 4&lt;/td&gt;
      &lt;td&gt;Columns:4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + Shift + 5&lt;/td&gt;
      &lt;td&gt;Gird 四方格&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + Shift + 8&lt;/td&gt;
      &lt;td&gt;Row：2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + Shift + 9&lt;/td&gt;
      &lt;td&gt;Row：3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
        <pubDate>Wed, 21 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/21/sublime_hotKey.html</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/21/sublime_hotKey.html</guid>
        
        <category>-tools</category>
        
        
      </item>
    
      <item>
        <title>工厂模式</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;九月(live)–旦增&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;简单工厂&quot;&gt;简单工厂&lt;/h2&gt;

&lt;p&gt;假如你有一家4s店，这家4s店并不是只卖一种品牌的车。现在最简单的方式可能是这种：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Car&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;orderCar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Car&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;audi&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Audi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;qirui&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;QiRui&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bwm&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bwm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;benz&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Benz&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;嗯，看起来还不错，但是如果现在4s店需要销售其他品牌的车就只能修改当前这个方法。现在有种办法是不是可以把生产汽车的代码抽出来放到一个factory中，factory来处理生产汽车的细节。代码像这样……&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SimpleCarFactory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Car&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createCar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Car&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;audi&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Audi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;qirui&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;QiRui&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bwm&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bwm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;benz&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Benz&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;虽然把生成汽车的代码抽了出来但是增加或者减少汽车的品牌仍然需要修改这段代码，但与之带来的好处是这个factory可以为多家4s店服务。当以后实现改变时，只要改变这个类就行了。&lt;/p&gt;

&lt;p&gt;重组后的4s店是这样的：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CarStore&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CarStore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SimpleCarFactory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;factory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Car&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;orderCar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Car&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createCar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另外可以利用静态方法定义一个简单的工厂，被称为&lt;code class=&quot;highlighter-rouge&quot;&gt;静态工厂&lt;/code&gt;。使用静态方法是因为不需要创建对象就可以使用，但是有相应的问题就是不能通过继承来改变创建方法的行为，这是为什么呢，通过继承来改变创建方法的行为在这里就是重写静态方法，&lt;code class=&quot;highlighter-rouge&quot;&gt;重写指的是根据运行时对象的类型来决定调用哪个方法，而静态方法在编译期就已经与编译出来的类型绑定了&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;工厂方法&quot;&gt;工厂方法&lt;/h2&gt;

&lt;p&gt;为了解决上面简单工厂增加或者减少汽车类型需要修改相关代码现在可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;工厂方法模式&lt;/code&gt;来解决这个问题，我们先来看一下工厂方法的定义：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;工厂方法模式 ：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在简单工厂里面现在增加生产江淮的汽车，就需要在createCar(String type)方法里面增加这种类型。现在可以这样解决，定义一个抽象工厂CarFacotry，定义一个抽象的工厂方法，让子类实现此方法制造产品。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CarFactory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Car&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createCar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们可以去实现具体的汽车工厂，比如BMWFactory、BenzFactory等，这样每一个类型的工厂只要只要这个类型的汽车就可以了。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BMWFactory&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CarFactory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Car&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Car&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createCar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bwm&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bwm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BenzFactory&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CarFacatory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Car&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Car&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createCar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;benz&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Benz&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在使用中直接把具体的汽车工厂通过CarStore的构造方法传进去就行了，然后orderCar的时候会去执行这个指定工厂的createCar()方法。&lt;/p&gt;

&lt;p&gt;下面是工厂方法简单的类图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-designPattern/post-designPattern-factoryPattern-1.png&quot; alt=&quot;factory method&quot; /&gt;&lt;/p&gt;

&lt;p&gt;工厂方法模式能够封装具体类型的实例化。抽象的Creator提供了一个创建对象的方法的接口，称为&lt;code class=&quot;highlighter-rouge&quot;&gt;“工厂方法”&lt;/code&gt;。在抽象的Creator中，任何其他实现的方法，都可能使用到这个工厂方法所制造出来的产品，但只有子类真正实现这个工厂方法创建产品。&lt;/p&gt;

&lt;p&gt;这里每一个具体的工厂的实现都像是SimpleFactory，区别在于这里的具体工厂是扩展自一个类，这个类有一个抽象的方法createCar()。由每个工厂自己来负责createCar()中的行为。另外简单工厂不具有工厂方法的弹性，简单工厂不能变更正在创建的产品，简单工厂添加删除类型需要修改那段代码，而工厂方法不需要。&lt;/p&gt;

&lt;h2 id=&quot;抽象工厂&quot;&gt;抽象工厂&lt;/h2&gt;

&lt;p&gt;在认识抽象工厂模式之前，我们先来认识一下&lt;code class=&quot;highlighter-rouge&quot;&gt;依赖倒置原则&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;依赖倒置原则(Dependency Inversion Principle)：要依赖抽象，不要依赖具体类
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个原则说明了：不能让高层组件依赖底层组件，不管高层或底层组件，“两者”都应该依赖于抽象。所谓“高层”组件，是由其他底层组件定义其行为的类。比如：在这里CarStore是个高层组件，因为它的行为是由Car定义的。&lt;/p&gt;

&lt;p&gt;比如像下面这样就是依赖具体类：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DependentCarStore&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Car&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;orderCar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Car&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;audi&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Audi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;qirui&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;QiRui&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bwm&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bwm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;benz&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Benz&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在DependentCarStore中，DependentCarStore依赖于具体的汽车类，这是违背依赖倒置原则的。如果要符合依赖倒置原则，我们需要做的转变就是定义一个Car接口，由CarStore来依赖于Car，然后具体的汽车类来实现这个接口，所以说也是依赖于Car。&lt;/p&gt;

&lt;p&gt;避免在OO设计中违反依赖倒置原则&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;变量不可以持有具体类的引用&lt;/li&gt;
  &lt;li&gt;不要让类派生自具体类&lt;/li&gt;
  &lt;li&gt;不要覆盖基类中已实现的方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们来认识一下抽象工厂模式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;抽象工厂模式 ： 提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;抽象工厂模式是为产品家族提供接口。家族在这里就是发动机、喇叭、车轮等。通过抽象工厂提供的接口，可以创建产品的家族，利用这个接口书写代码，我们的代码将从实际工厂解耦，以便实现不同的工厂，制造出各种不同的产品。奔驰、宝马、江淮汽车的各个零件都是不一样的，在这里我们可以分别的生产不同的零件。&lt;/p&gt;

&lt;p&gt;首先我们先来建一个零件工厂：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CarComponentsFatory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Engine&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createEngine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tire&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createTire&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Horn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createHorn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接下来先来实现奔驰零件工厂，Benz用到的零件都是比较好的：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BenzCarComponentsFatory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Engine&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createEngine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;HighEngine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tire&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createTire&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;HighTire&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Horn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createHorn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;HighHorn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而江淮的车使用到的零件就比Benz差了，所以使用低档次的零件：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JHCarComponentsFactory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Engine&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createEngine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LowEngine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tire&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createTire&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LowTire&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Horn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createHorn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LowHorn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;零件工厂已经准备好了，我们重新开始生产汽车，先从抽象的Car类开始：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Car&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Engine&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;engine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Tire&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tire&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Horn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;horn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;toString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;......&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;现在已经有了一个抽象的汽车类了，现在开始创建奔驰和江淮的汽车了。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BenzCar&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Car&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CarComponentsFatory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;carComponentsFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;BenzCar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CarComponentsFactory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;carComponentsFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;carComponentsFactory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;carComponentsFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;engine&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;carComponentsFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createEngine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;tire&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;carComponentsFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createTire&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;horn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;carComponentsFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createHorn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同样创建江淮汽车也是如此，并且可以在这基础上有自己的修改。&lt;/p&gt;

&lt;p&gt;好了，现在我们去4s店购买汽车：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BenzCarStore&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CarStore&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Car&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createCar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Car&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CarComponentsFatory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;componentsFactory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BenzCarComponentsFatory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
       
        &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BenzCar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;componentsFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;；&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Benz&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在这里我们创建BenzCar然后让它与Benz零件工厂绑定在一起，之后就可以调用execute()方法让工厂去生产零件。可以看到在这里我们甚至可以使用JH零件工厂来给Benz生产零件，但是呢这肯定会被投诉的。&lt;/p&gt;

&lt;p&gt;现在你可以对比一下工厂方法和抽象工厂，其实抽象工厂的每个方法实际上都是使用工厂方法来实现的。比如createEngine()等，每个方法都被声明为抽象，而子类的方法覆盖这些对象来创建某些对象。&lt;/p&gt;

&lt;p&gt;但是，工厂方法创建对象用的方法是继承，利用工厂方法创建对象需要扩展一个类，而抽象工厂是通过对象的组合。工厂方法模式和抽象方法模式比较容易搞混，在使用中工厂方法是用来创建一个产品。而抽象工厂是可以被用来创建整个产品家族的。如果使用抽象工厂创建产品，加入新产品就必须改变其接口了。&lt;/p&gt;

&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;三种工厂模式各有各的用处，简单工厂用于简单的创建一个产品，工厂模式在简单工厂的基础上可以增加产品类型，抽象工厂用于创建整个产品家族的，可以根据具体的情况选择使用对应的工厂模式。这是我目前理解的工厂模式，会有一些理解不准确不到位的地方，希望大家能多多指教。&lt;/p&gt;

</description>
        <pubDate>Sat, 10 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/10/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/10/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html</guid>
        
        <category>-designPattern</category>
        
        
      </item>
    
      <item>
        <title>Linux命令：top</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;温暖(live) –tiger&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;常用参数&quot;&gt;常用参数&lt;/h2&gt;
&lt;p&gt;Linux中&lt;code class=&quot;highlighter-rouge&quot;&gt;top&lt;/code&gt;命令用于&lt;code class=&quot;highlighter-rouge&quot;&gt;实时显示process的动态&lt;/code&gt;。&lt;br /&gt;
top命令有一些常用的参数：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;-d&lt;/strong&gt;: 改变显示的更新速度，或是在交谈式指令列按&lt;code class=&quot;highlighter-rouge&quot;&gt;s&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;-q&lt;/strong&gt;: 没有任何延时的显示速度，如果使用是以&lt;code class=&quot;highlighter-rouge&quot;&gt;superuser&lt;/code&gt;的权限执行，则top以最高的优先序执行。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;-c&lt;/strong&gt;: 显示完成的&lt;code class=&quot;highlighter-rouge&quot;&gt;command&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;-n&lt;/strong&gt;: 更新的次数，完成之后将会退出top。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;-p 139&lt;/strong&gt;: 显示进程Id为139的进程信息，CPU，内存占用率等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;输出信息介绍&quot;&gt;输出信息介绍&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/img/in-post/post-linux/post-top-1.png&quot; alt=&quot;top命令输出信息&quot; /&gt;&lt;br /&gt;
我们从图片中可以看到这些信息，首先第一行，当前时间，系统运行时间，当前登录用户，最后一项是系统负载，三个数值分别是1分钟，5分钟，15分钟到现在的平均值。第二行，任务的总数，zombie是僵尸进程数。第三行，&lt;code class=&quot;highlighter-rouge&quot;&gt;0.6%us&lt;/code&gt;: 用户空间占用CPU百分比，&lt;code class=&quot;highlighter-rouge&quot;&gt;0.3%sy&lt;/code&gt;: 内核空间占用CPU百分比，&lt;code class=&quot;highlighter-rouge&quot;&gt;0.1%ni&lt;/code&gt;: 用户进程空间内改变过优先级的进程占用CPU百分比，&lt;code class=&quot;highlighter-rouge&quot;&gt;98.9%id&lt;/code&gt;: 空闲CPU百分比，&lt;code class=&quot;highlighter-rouge&quot;&gt;0.0%wa&lt;/code&gt;: 等待输入输出的CPU时间百分比，&lt;code class=&quot;highlighter-rouge&quot;&gt;0.0%hi&lt;/code&gt;: Hardware IRQ，&lt;code class=&quot;highlighter-rouge&quot;&gt;0.0%si&lt;/code&gt;: Software IRQ。另外，IRQ: IRQ全称为Interrupt Request，即是“中断请求”的意思。st(Steal Time): stole time 的缩写，该项指标只对虚拟机有效，表示分配给当前虚拟机的CPU 时间之中，被同一台物理机上的其他虚拟机偷走的时间百分比。&lt;br /&gt;
后面两行根据名字就能看出相应的意思，这里介绍一下&lt;code class=&quot;highlighter-rouge&quot;&gt;buffer&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;cache&lt;/code&gt;的区别:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;可用内存 = 系统&lt;code class=&quot;highlighter-rouge&quot;&gt;free memory + buffers + cached&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;buffers&lt;/code&gt;是指用来给块设备做的缓冲大小，他只记录文件系统的&lt;code class=&quot;highlighter-rouge&quot;&gt;metadata&lt;/code&gt;以及&lt;code class=&quot;highlighter-rouge&quot;&gt;tracking in-flight pages&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cached&lt;/code&gt;是用来给文件做缓冲&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那就是说：&lt;code class=&quot;highlighter-rouge&quot;&gt;buffers&lt;/code&gt;是用来存储，目录里面有什么内容，权限等等。而&lt;code class=&quot;highlighter-rouge&quot;&gt;cached&lt;/code&gt;直接用来存储我们打开的文件。&lt;br /&gt;
&lt;img src=&quot;/img/in-post/post-linux/post-top-2.png&quot; alt=&quot;top命令输出信息&quot; /&gt;&lt;br /&gt;
这些字段的意思我们可以从下面两张图中了解：
&lt;img src=&quot;/img/in-post/post-linux/post-top-3.png&quot; alt=&quot;top命令输出信息&quot; /&gt;
&lt;img src=&quot;/img/in-post/post-linux/post-top-4.png&quot; alt=&quot;top命令输出信息&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;f &lt;/code&gt;键可以选择显示的内容。按&lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt;键之后会显示列的列表，按&lt;code class=&quot;highlighter-rouge&quot;&gt;a-z&lt;/code&gt;即可显示或隐藏对应的列，最后按回车键确定。&lt;/li&gt;
  &lt;li&gt;按&lt;code class=&quot;highlighter-rouge&quot;&gt;o&lt;/code&gt;键可以改变列的显示顺序。按小写的&lt;code class=&quot;highlighter-rouge&quot;&gt;a-z&lt;/code&gt;可以将相应的列向右移动，而大写的&lt;code class=&quot;highlighter-rouge&quot;&gt;A-Z&lt;/code&gt;可以将相应的列向左移动，最后按回车键确定。&lt;/li&gt;
  &lt;li&gt;按大写的&lt;code class=&quot;highlighter-rouge&quot;&gt;F&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;O&lt;/code&gt;键，然后按&lt;code class=&quot;highlighter-rouge&quot;&gt;a-z&lt;/code&gt;可以将进程按照相应的列进行排序。而大写的&lt;code class=&quot;highlighter-rouge&quot;&gt;R&lt;/code&gt;键可以将当前的排序倒转。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;常用交互命令&quot;&gt;常用交互命令&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Ctrl+L&lt;/strong&gt;: 擦除并且重写屏幕。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;h&lt;/strong&gt;或者&lt;strong&gt;?&lt;/strong&gt;: 显示帮助画面，给出一些简短的命令总结说明。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;k&lt;/strong&gt;： 终止一个进程。系统将提示用户输入需要终止的进程PID，以及需要发送给该进程什么样的信号。一般的终止进程可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;15信号&lt;/code&gt;；如果不能正常结束那就使用&lt;code class=&quot;highlighter-rouge&quot;&gt;信号9&lt;/code&gt;强制结束该进程。默认值是&lt;code class=&quot;highlighter-rouge&quot;&gt;信号15&lt;/code&gt;。在安全模式中此命令被屏蔽。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;i&lt;/strong&gt;： 忽略闲置和僵死进程。这是一个开关式命令。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;q&lt;/strong&gt;： 退出程序。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;r&lt;/strong&gt;： 重新安排一个进程的优先级别。系统提示用户输入需要改变的进程PID以及需要设置的进程优先级值。输入一个正值将使优先级降低，反之则可以使该进程拥有更高的优先权。默认值是&lt;code class=&quot;highlighter-rouge&quot;&gt;10&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;S&lt;/strong&gt;： 切换到累计模式。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;s&lt;/strong&gt;： 改变两次刷新之间的延迟时间。系统将提示用户输入新的时间，单位为&lt;code class=&quot;highlighter-rouge&quot;&gt;s&lt;/code&gt;。如果有小数，就换算成&lt;code class=&quot;highlighter-rouge&quot;&gt;ms&lt;/code&gt;。输入&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;值则系统将不断刷新，默认值是&lt;code class=&quot;highlighter-rouge&quot;&gt;5s&lt;/code&gt;。需要注意的是如果设置太小的时间，很可能会引起不断刷新，从而根本来不及看清显示的情况，而且系统负载也会大大增加。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;f&lt;/strong&gt;或者&lt;strong&gt;F&lt;/strong&gt;： 从当前显示中添加或者删除项目。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;o&lt;/strong&gt;或者&lt;strong&gt;O&lt;/strong&gt;： 改变显示项目的顺序。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;l&lt;/strong&gt;： 切换显示&lt;code class=&quot;highlighter-rouge&quot;&gt;平均负载&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;启动时间信息&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;m&lt;/strong&gt;： 切换显示&lt;code class=&quot;highlighter-rouge&quot;&gt;内存&lt;/code&gt;信息。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;t&lt;/strong&gt;： 切换显示&lt;code class=&quot;highlighter-rouge&quot;&gt;进程&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;状态信息。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;c&lt;/strong&gt;： 切换显示&lt;code class=&quot;highlighter-rouge&quot;&gt;命令名称&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;完整命令行&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;M&lt;/strong&gt;： 根据驻留内存大小进行排序。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;P&lt;/strong&gt;： 根据CPU使用百分比大小进行排序。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;T&lt;/strong&gt;： 根据时间/累计时间进行排序。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;W&lt;/strong&gt;： 将当前设置写入&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.toprc&lt;/code&gt;文件中。这是写top配置文件的推荐方法。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 15 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/15/Linux%E5%91%BD%E4%BB%A4-top.html</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/15/Linux%E5%91%BD%E4%BB%A4-top.html</guid>
        
        <category>-Linux</category>
        
        
      </item>
    
  </channel>
</rss>
