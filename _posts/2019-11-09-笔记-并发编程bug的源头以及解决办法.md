---
layout:     post
title:      "笔记-并发编程bug的源头以及解决办法"
subtitle:   " "
date:       2019-11-09
author:     "huailei"
header-img: "img/home-bg-o.jpg"
tags:
    -concurrency
---

### 缓存导致的可见性问题
**可见性**是一个线程对共享变量的修改，另外一个线程能立刻看到。

为了提高处理速度，处理器不直接与内存进行通信，而是先将系统内存的数据读到内部缓存后再进行操作，但操作完不知道何时会写到内存。对于单核来说，所有的线程都是运行在这个CPU上的，操作的都是同一份缓存。线程A更新了变量V的值，那么线程B之后再访问变量V,得到的一定是V的最新值。

但是在多核上，每一个CPU都有自己的缓存，线程A运行在CPU-1上，操作的是CPU-1的缓存，线程B运行在CPU-2上，操作的是CPU-2的缓存。这时候线程A对于变量V的操作对于B就不具备可见性了。
![多核CPU的缓存与内存关系图](https://static001.geekbang.org/resource/image/e2/ea/e2aa76928b2bc135e08e7590ca36e0ea.png)

### 可见性问题解决办法
可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。这就需要一个CPU上缓存中的共享变量被修改，其他CPU就需要知道这个被修改的共享变量以及最新的值。但是如何做到信息的传递的呢？我们来看一下volatile是如何来保证可见性的？有volatile变量修饰的共享变量进行写操作的时候会引发下面两个操作：
- 将当前处理器缓存行的数据写回系统内存
- 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效

在多处理下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现 自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存中。通过这样就能保证一个线程修改共享变量之后，另外一个线程操作的是最新的值。

### 线程切换带来的原子性问题
操作系统允许某个进程执行一小段时间，过了这小段时间就会再选择一个进程来执行，这小段时间被称为“**时间片**”。
![线程切换示意图](https://static001.geekbang.org/resource/image/25/fb/254b129b145d80e9bb74123d6e620efb.png)
而执行每个线程的时间片是不一定的。有可能执行一条CPU指令就切换到其他线程执行了。
现在我们使用的都是高级语言，每一条语句都是解析成多条CPU指令的，比如count += 1就可以至少三条CPU指令。
1. 需要把变量count从内存加载到CPU的寄存器。
2. 在寄存器中执行+1操作。
3. 将结果写入内存（缓存机制是写入缓存，然后由缓存写入内存）

操作系统做线程切换，可以发生在执行任何一条CPU指令之后，当A线程执行到1后发生线程切换，由B线程开始执行1，2，3三条CPU指令，B线程执行完之后再切换到A线程执行，最终我们会发现结果是1而不是2。这主要是三条CPU指令执行并不是一体的，我们把一个或多个操作在CPU执行的过程中不被中断的特性称为原子性，CPU只能保证执行CPU指令的时候具有原子性，不能保证执行多条CPU指令具有原子性。所以很多时候我们需要在高级语言层面保证操作的原子性。

### 原子性问题解决办法
在Java中可以通过**锁**和**循环CAS**的方式来实现原子操作。锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM中的CAS操作利用了处理器提供的CMPXCHG指令实现的，而CMPXCHG指令是处理器用来保证原子性的，处理器提供的这些指令，除了CMPXCHG之外还有位测试和修改指令（BTS、BTR、BTC）以及操作数和逻辑指令（如AD和OR），这些指令可以实现两个机制来保证处理器实现原子性，第一个机制是通过总线锁保证原子性，第二个机制是通过缓存锁定来保证原子性，被这些指令操作的内存区域就会加锁，导致其他处理器不能同时访问它。

### 编译优化带来的有序性问题
有序性：指的是程序按照代码的先后顺序执行。

为了提高性能，编译器和处理器常常会对指令做重排序。比如 a=1;b=2;可以被编译器优化后变成 b=2;a=1;这个例子中只是调整了语句的顺序，并没有改变最后的结果。
重排序的3种类型：
1. 编译器优化的重排序。编译器可以在不改变单线程语义的前提下，重新安排语句的执行顺序。
2. 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
3. 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

上面说的1是编译器重排序，2和3是属于处理器重排序。这些重排序可能会导致多线程程序出现**内存可见性问题**。在Java中有个经典的案例，双重检查创建单例对象。
```java
public class Singleton {
  static Singleton instance;
  static Singleton getInstance(){
    if (instance == null) {
      synchronized(Singleton.class) {
        if (instance == null)
          instance = new Singleton();
        }
    }
    return instance;
  }
}
```
上面代码表达的意思，如果第一次检查instance不为空，就不需要执行下面的加锁和初始化操作。因此，可以大幅降低synchronized带来的开销。多个线程试图在同一时间创建对象时，会通过加锁来保证只有一个线程能创建对象。在对象创建好之后，不需要获取锁直接返回已创建好的对象。好像非常完美，但还是有问题。问题就出现在new Singleton()上。创建一个对象，我们以为的操作是：
1、分配一块内存M；
2、在内存上初始化Singleton对象；
3、然后M的地址赋值给instance变量。

但是可能实际优化之后的执行顺序是这样的：
1、分配一块内存M；
2、把M的地址赋值给instance变量；
3、最后在内存上初始化Singleton对象。

优化后会导致通过getInstance()获取对象时，这个对象还没有在内存上初始化，如果此时访问instance的成员变量就有可能触发空指针异常。

![双重检查创建单例对象的异常执行路径](https://static001.geekbang.org/resource/image/64/d8/64c955c65010aae3902ec918412827d8.png)

### 有序性问题解决办法
从上面知道重排序可能会导致多线程程序出现内存可见性问题。为了保证内存可见性，最直接的办法就是**禁止重排序**。对于编译器，JMM的编译器重排序规则会禁止特定类型的排序(例如volatile)，对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障(Memory Barriers)指令，通过内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指令分为4类：
屏障类型 | 指令示例 | 说明
---|---|---
LoadLoad Barriers | Load1;LoadLoad;Load2 | 确保Load1数据的装载先于Load2及所有后续装载指令的装载
StoreStore Barriers | Store1;StoreStore;Store2 | 确保Store1数据对其他处理器可见（刷新到内存）先于Store2及所有后续存储指令的存储
LoadStore Barriers | Load1;LoadStore;Store2 | 确保Load1数据装载先于Store2及所有后续的存储指令刷新到内存
StoreLoad Barriers | Store1;StoreLoad;Load2 | 确保Store1数据对其他处理器变得可见（指刷新到内存）先于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令

### Java是如何解决可见性和有序性问题的
从上面知道导致可见性问题的原因是缓存，导致有序性问题的原因是重排序。那么最直接的办法就是**禁用缓存**和**禁止重排序**。但是全部都禁用就会大大降低程序的性能，那么最好的方案就是**按需禁用缓存和禁止重排序**。所以Java内存模型规范了JVM如何提供按需禁用缓存和禁止重排序的方法，具体来说就是**volatile、synchronized和final**关键字，以及**happens-before**规则。JMM使用happens-before的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间存在happens-before关系。这里的两个操作可以是在一个线程之内，也可以是在不同的线程之间。

那如何理解happens-before规则呢？

两个操作之间存在happens-before关系，并不是说前一个操作必须要在后一个操作之前执行，它真正表达的是**前一个操作的结果对后续操作是可见的**。happens-before规则约束了编译器的优化行为，虽然允许编译器优化，但是要求编译器优化后一定要遵守happens-before规则。

happens-before规则和程序员相关的共有六条规则，都是关于可见性的。

1、程序的顺序型规则：是指在一个线程中，按照程序顺序，前面的操作happens-before于后续的任意操作。

2、volatile变量规则：对一个volatile变量的写操作，happens-before于后续对这个变量的读操作。

3、传递性：如果A happens-before B，B happens-before于 C，那么A happens-before 于 C。

4、管程中锁的规则：对一个锁的解锁happens-before于后续对这个锁的加锁。管程是一种通用的同步原语，在 Java 中指的就是 synchronized。

5、线程start规则：主线程A启动子线程B后，子线程B能看到主线程在启动子线程B前的操作。

6、线程join()规则：主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程B 的 join() 方法实现），当子线程B完成后（主线A 中join()方法返回），主线程能够看到子线程的操作。

下面用例子解释一下这六条happens-before规则：
因为volatile变量规则和锁的规则类似，这里只以1，2，3做说明。下面是以volatile写-读的示例。

```java
class VolatileExample {
  int x = 0;
  volatile boolean v = false;
  public void writer() {
    x = 1;  //1
    v = true;  //2
  }
  public void reader() {
    if (v) {  //3
      // 这里 x 会是多少呢？
      System.out.println(x);  //4
    }
  }
}
```
上面程序x的值是多少呢？如果是1.5之前的版本，结果可能是0，如果是1.5及之后的版本，结果就是1。
我们来用happens-before规则来分析一下这段程序的执行。假设此时线程A执行writer()方法，线程B执行reader()方法。

从上面来看：
- 1 happens-before 2 和3 happens-before 4是由程序顺序规则来产生。
- 2 happens-before 3是由volatile变量规则来产生，因为由volatile变量规则，对一个volatile变量的读，总是能看到（任意线程）之前对这个volatile变量最后的写入。
- 1 happens-before 4是由传递性规则来产生。这里的传递性是由volatile的内存屏障插入策略和volatile的编译器重排序规则共同来保证的。

那么v被volatile修饰，操作1和操作2还可能重排序吗？如果没有的话，那么volatile做了哪些事情呢？

### 参考
- Java并发编程的艺术
- Java并发编程实战
- [Java并发编程](https://time.geekbang.org/column/intro/159)