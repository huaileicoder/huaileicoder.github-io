---
layout:     post
title:      "工厂模式"
subtitle:   "简单工厂、工厂方法与抽象工厂"
date:       2018-11-10
author:     "huailei"
header-img: "img/post-bg-linux-order.jpg"
tags:
 	- design pattern
---
> 九月(live)--旦增

## 简单工厂

假如你有一家4s店，这家4s店并不是只卖一种品牌的车。现在最简单的方式可能是这种：

```java
public Car orderCar(String type) {
    Car car = null;

    if (type.equals("audi")) {
        car = new Audi();
    }
    if (type.equals("qirui")) {
        car = new QiRui();
    }
    if (type.equals("bwm")) {
        car = new Bwm();
    }
    if (type.equals("benz")) {
        car = new Benz();
    }

    car.execute();
    return car;
}
```

嗯，看起来还不错，但是如果现在4s店需要销售其他品牌的车就只能在这个方法中修改了。现在有种办法是不是可以把生产汽车的代码抽出来放到一个factory中，factory来处理生产汽车的细节。代码像这样......

```java
public class SimpleCarFactory {
    public Car createCar(String type) {
        Car car = null;
        if (type.equals("audi")) {
            car = new Audi();
        }
        if (type.equals("qirui")) {
            car = new QiRui();
        }
        if (type.equals("bwm")) {
            car = new Bwm();
        }
        if (type.equals("benz")) {
            car = new Benz();
        }
        return car;
    }
}
```

虽然把生成汽车的代码抽了出来但是增加或者减少汽车的品牌仍然需要修改这段代码，但与之带来的好处是这个factory可以为不止一家4s店服务。当以后实现改变时，只要改变这个类就行了。

重组后的4s店是这样的：

```java
public class CarStore {
    private factory;
    
    public CarStore(SimpleCarFactory factory) {
        this.factory = factory;
    }
    
    public Car orderCar(String type) {
        Car car = null;
        car = factory.createCar(type);
        car.execute();
        return Car;
    }
}
```

另外可以利用静态方法定义一个简单的工厂，被称为静态工厂。使用静态方法是因为不需要创建对象就可以使用，但是有相应的问题就是不能通过继承来改变创建方法的行为，这是为什么呢，通过继承来改变创建方法的行为在这里就是重写静态方法，重写指的是根据运行时对象的类型来决定调用哪个方法，而静态方法在编译期就已经与编译出来的类型绑定了。



## 工厂方法

为了解决上面简单工厂增加或者减少汽车品牌需要修改相关代码现在可以使用`工厂方法模式`来解决这个问题，我们先来看一下工厂方法的定义：

```
工厂方法模式 ：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。
```

在简单工厂里面现在增加生产江淮的汽车，就需要在createCar(String type)方法里面增加这种类型。现在可以这样解决，定义一个抽象工厂CarFacotry，定义一个抽象的工厂方法，让子类实现此方法制造产品。

```java
public abstract class CarFactory {
    public abstract Car createCar(String type);
}
```

我们可以去实现具体的汽车工厂，比如BMWFactory、BenzFactory等，这样每一个类型的工厂只要只要这个类型的汽车就可以了。

```java
public class BMWFactory extends CarFactory {
    private Car car;
    public Car createCar(String type) {
        if (type.equals("bwm")) {
            car = new Bwm();
        }
        return car;
    }
}
```

```java
public class BenzFactory extends CarFacatory {
    private Car car;
    
    public Car createCar(String type) {
        if (type.equals("benz")) {
            car = new Benz();
        }
        return car;
    }
}
```

！[factory method](/img/in-post/post-designPattern/post-designPattern-factoryPattern-1.png)

```
工厂方法模式能够封装具体类型的实例化。抽象的Creator提供了一个创建对象的方法的接口，称为“工厂方法”。在抽象的Creator中，任何其他实现的方法，都可能使用到这个工厂方法所制造出来的产品，但只有子类真正实现这个工厂方法创建产品。
```

这里每一个具体的工厂的实现都像是SimpleFactory，区别在于这里的具体工厂是扩展自一个类，这个类有一个抽象的方法createCar()。由每个工厂自己来负责createCar()中的行为。另外简单工厂不具有工厂方法的弹性，简单工厂不能变更正在创建的产品，简单工厂添加删除类型需要修改那段代码，而工厂方法不需要。

## 抽象工厂

